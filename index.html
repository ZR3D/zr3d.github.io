<!DOCTYPE html>
<html lang="en">
<head>
<title>Geo Abc</title>
<link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAKdklEQVR4nNVbXWhbyRX+5korrY2EtVXiXZt4pZJWboKD1fW+xCz4htBsF2SiXfcl+2KFJJKhhTpJKez2oQ4JpQ/r1ktLk+ukRIbWIYG0CvbLhs2uDCWGUoNMDMYiBhkHG4xcripjISF5+nBzZf3cn7lXcpp+T9LcmTMzZ86cOXPOGYKDxoU7HpCiHxzxg1IvAK9OixQISWGPJkCtCfz54tpBDo8cCNWwMAxKeRDwAPE2RoymQBEHIXFMRqYaH1w1mseAC3c8sJRGQRECgYulSVuLDUG/F1PzSbY+KEQQRFGyTDRLMhpnwKXJAWBvDITwRpsOn/RhLNCH7/7qnpmeYyB0DMLIopnGMswzQFrxCQBBsyS+vRIA390J//WHWHyxbY4IpVEQMorJSMZMc85Up2FhGFwpgQYm73E7wHd3AgBGT/eYJQMQEgJoQpJE4zDGgLDQhrDwdwBR1n2uhtHTJ8q/g35vI6QAEC8IjePSrbtGW7IzIHKrF6DlVe9w2Iz2VYVgr7f829Vqx/BJn2la5bEQEsKlW98iLLSxtmVjQORWL/ZIvPJIG+x248rJI3DYLAaGKuFsrwfeQ86qMjNS0OGwQQj40OmsWAxCeFDEWZmgz4Cw0AaKWK3IL2xk8emJtzE9dAx9HQ5DAw/1d9eVBf1eeNzsdM71tEt9dzqxsLlT/ZHADyDKQkebAdLk40rGzMLmDrL5IjqddgiD3fjizFEmaZDPfiVUbgs1+NwtEAI+XO3vgtNuRTwlqlUNsugEPQmIvuSmIio5z3tdmDnXgwGPtuSFNPZ6qF9bD4T7OjA9dBx9nfvbZ2Ejq96AkBDCwu+1aKozQGqoeczVdu60WzH+4fcgBHyqSrJS+9fC33UIvUfcdeU+dwv++skxhPs668ewqcGAl10iLAyrfVRmwMVbZwGM6lFWE7++Tiemh47hXE97VXnvEXed8qtFpRQ4bJbyqncfaq2ru5HNI7md0xsmQDEhnWL1qGdAWGgDhwl9qsDmTgEb2bziN6fdiqv9XRACPvjcLQDYDB55i/R1ODA9pLzqMjTFvxIELuwpz6lea/UN/hYgP2ajLImn0urI6HTaMXT8MCwWC376o/fw5htWTXpvvmHFMZcFwz3fgdOuXffe0habBAAAIV70DQILs3OVxdUSIImJruhXQkMLV+GXp4/D1WpnqvvhCW9T+y6DYrTWPqhmgIqYaKHuDFaB212v3NTgcrlgsWgfqSvpXewUSsw0AUhbgdKqOe4z4MIdj5kr7U6hhJX0rmYdm80Gp1Nb+dVCj2EM2l8ZhIRw4Y5H/rvPAK44Zo6i/mDa29s1vytBlwGsClAJllJ5m0sMCAttADF9tZ3T2Ysul/GLY2trK1paWtT7XDN1/ZdAEZJ/ymo2aPR623vEDVfrvrHjcDhgt9ths1UbQDabDXY7m/KrRVdXF7LZ6pUulUpIrG9jwNdRVT6X3GQnTOBCWBjGZGRqnwGQ7PRoiIerpXoSsuPiVcPpdCrqjq6uLgz2q1roZSTW0xB3C1Vlow/mZe9TEMCU5BILC1Su0NZiQ/xqAP6uQw0N/nWDuJsHPz6773qjEHE78hbBpckBEBqvbXB3eEDx2vr/iMR6Gvz4LDK5amkAoX4O2FOUpfNTcxi9//RVjO9AEX26ojx5ANgDzwHq190vv1kCPz4DcVfZ3n/dMXr/Kc5PzSlPXoKfg06oai65Cf+Nh0isp5s9vgODtN9n8OU3S3pVvRyIbqwOa9s74MdnEUukmjG+A4W835mORQKvBX2DTPZ/vljC/X+tAvjfHYt6iCVSCN58jLV/s91PAOIyHBi5NruAUDT+2umFiSfP8PHNx1r7XRHaF24VTM0nsbol4uuff2TaymsWisUiLv7lH+wB1hqYCo353C24/kEHlpeX60zVV4l8Po9kMol+N0zFJwATDAj43JgeOg6n3YpSqYRkMol0+tWfELu7u1heXkYulyv7IGXXmxFY0Dc4xlLRYbPgsw/eReT9egWYyWRQKBRM3frMIJ1O4/nz56C0bMHDabfizNG3sJ0rsrvJAFjw3mAQBO9oVepw2PCHj76P/nfVff65XA6iKOLw4cPMnZvB+vo6NjY2FL/ZrRx4rwsOmwXzL/6jT4wiwQFU8zIve2e1HJ8y9NxYzQBLH5+eeBtCwMegF6jIgZCE2udzPe0QBrt1vbMyjLq9zIC1Dya9QEiCA6Wp2nKHzYIvzhzF1f4uQ4N7FTrA6XQyS1qn0w4h4EPAp+JeozTFgUO8skwOPvJeY5OxWCxobdXfJs2Aw8EeRXbarRjjvbhy8kj9Rw5xrjLJaMDTBiHgY9rvjQyqUZjZanV6gUKEMLIob+4YgODcWganpqqTrjoctuoEBEhbpJZJPztT7aM7SLhcLjz65zKyhRKS2/su+Wy++j+gFbegMWDfFI5BJRK8uVPA5k69fV3rlf3sk4NXgDLsdjt+M7+BtW3WS48CKGLAviUYa2RAHrdDN+rbbPC+Bm6kFCLujDwCZAZMRjKgNGqWHktmhxJEUYQoGozvyX02lFlGywu+f8BzmKgMGBiBUf9AsVhEKpVCJiNto7a2Nni9Xlit7JdT3teAztmzjsk/9y9DwsgiaL13uNmDEUURS0tL5ckD0l1iaWnJkDS4Wu2K2SS6oDRamWdcfRvkjIXGATlCpO8TKBaLeP78OVZXV1Eq1Ud1S6USVldXsbKyglSa7YptSgoqVh+oZYBkExgKkbPsxVgihZ/8cbZq1dWwkNqC/8ZDTDx51pS+azBWm2Wu5A8YAwWzLGqtgribR/BPX+Hjm4/xaHlLNZ2mEveWtpDJFXD5wTz48RlNaTCkeygSmIxcqy2uZ8BkJMMaKW5rsakOYuLJM3g/v4dHi/sMZ8noqKwju+THZhZU65/t9ah+q8KeRXFOyh6h2+E5AGN6NJVWP5XOgh+fweUH83UOynvPtjTpzayk67I+MrkCrs0uwH9dOTbBJAV7NKj2wELdJSaJi6aBVNv5xJNn8N94qOqT39wpaCY2zCbV3wwsvtjGD2/8rU4aGBThhGz0KEHPJxgChaq/QDaAtFa9FjMqk9zI5pnyja7NLsD7+TTiK5JXyN91SD3HmNIoJiOXtehpM2AykgEBr2QfyOav3qrXIp4Skc0X68q1Vr8Wa9s7OPW7WYzefyqFwZTN4gncHjmvR4v9ycylW3el1xkS5AwNQ5kZL/HrAQ8Gu6vzDwannyleuvTgcTvA+zpr4wIh1hdmxt4M1TDBLHzuFkwPHS//j6dE/OLxaqNkZTBPHjAaF5BEypCdoITkdq7KJjCc8KgEChF7NGj0baHxyNBk5Bo4ymspRxbIR2I2XzS0/xVBaRwc5bW0vRrMvRoTRhalV6HGM0tlyKeB2qnADEpHcXvklNn3g+Yd+QuzeSzMfoX3AzGAvAPgB0aaF0oUPncr7i1tYTtXfyrogtIoOIQwaXzVK9G8p7NSstUoDLwl7HDYjGt+SqMAF31prTaM5j+evnDHA64YBEhI67mNIUh2SAx71lizX5MfzOtxGVJqehCAF5TyAPHrZqRSiABNgJA49mgCHImbfRbLgv8C63LF4Yc64OgAAAAASUVORK5CYII=">
<meta content="width=device-width, initial-scale=1, name="viewport">
<style>
* { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
body { font-family: sans-serif; font-size: 13px; padding: 0; margin: 0; background-color: #627385; }
button { font-family: sans-serif; font-size: 13px; background-color: #415d77; border: none; color: white; text-decoration: none; display: inline-block; cursor: pointer; border-radius: 3px; height: 25px; overflow: hidden; vertical-align: middle; float: left; margin-right: 4px; z-index: 10; }
button.btn-multiple { margin: 0 5px 5px 0; }
button.minus-btn {border-radius: 3px 0 0 3px; margin: 0;}
button.plus-btn {border-radius: 0 3px 3px 0;}
button:hover{background-color: #3b4f61;}
.label { display: inline-block; float: left; padding-top: 4px; margin: 0 5px 0 14px; }
select, input[type=text] , textarea{ padding: 4px; display: inline-block; float: left; border-radius: 3px; margin-right: 5px; border: none; }
#main {margin:0px; padding:px;}
#topPanel { position: fixed; left: 0; top: 0; width: 100%; background-color: #4b5c6e; color: #f1f1f1; padding: 5px 5px 3px 2px; z-index:10;}
#topInfoPanel {position: fixed; left: 0px; top: 35px; background-color: #2d476033; color: #f1f1f1; padding: 7px 5px 6px 15px; z-index:10; width:1080px}
#topPanel div { float: left; }
#topPanel button{background-color:#919aa3;}
#svgHolder {margin-top: 35px; float: left; }
#controlPanel {float: left; background-color: #9fa6ae; width: 350px; height: 1080px; margin-left: 1080px; position: fixed; top: 35px; z-index: 10; }
#controlPanel .label {width: 85px; color: #f1f1f1; margin-left: 0; overflow: hidden; text-wrap: nowrap;}
#controlPanel .btn-on {padding: 2px 4px; text-align: center; width: 21px; border: 2px solid #f1f1f1; }
.control-box {float: left; padding: 4px 5px 4px 5px; width: 340px; margin: 0 0 2px 5px; position: relative;  background-color:#b1b5bb;}
.control-box-first {margin-top: 5px;}
.control-box-last {margin-bottom: 5px;}
.container.control-box:last{padding-bottom:10px;}
.cp-header {background-color: #2d4760; padding: 3px 0 3px 10px; color: #f1f1f1; width: 100%; margin: 0 0 1px 0; cursor: pointer; }
.number-text {background-color: #f1f1f1; padding: 5px 7px; color: #000; float: left; }
.btn-off {background-color: #374838; }
#pointButtons .btn-off, #shapeButtons .btn-off { display: none; }
#tooltip {background-color: #ccc; padding: 8px; color: #f1f1f1; border-radius: 3px; z-index: 1; }
#pointContainer, #shapeContainer, #patternContainer, #toolContainer, #designContainer, #exportContainer { transition: all 1s; }
.hide {height: 0px; overflow: hidden; }
.hide div {display: hidden; }
.show{height:200px;}
#skipBtnContainer .btn-on { border: none; }
.green-btn{width: 15px; height: 15px; border-radius: 15px; margin-top: 4px; background-color: #66B032; cursor: pointer; float: left; border: none; }
.green-btn-on{}
.green-btn-off{background-color: #374838; }
.title{width:85%; float:left;}
.chevron {float:left;  display: block;  height: 20px; /*height should be double border*/}
.chevron::before,.chevron::after {position: absolute;  display: block;  content: "";  border: 10px solid transparent; /*adjust size*/}
.chevron.down::before {top: 9px;  border-top-color: #9fa6ae; /*Chevron Color*/}
.chevron.down::after {top: 4px; /*adjust thickness*/  border-top-color: #2d4760; /*Match background colour*/}
.chevron.up::before {top: 0px;  border-bottom-color: #9fa6ae; /*Chevron Color*/}
.chevron.up::after {top: 5px; /*adjust thickness*/  border-bottom-color: #2d4760; /*Match background colour*/}
.svg-text{font-family: sans-serif; font-size: 13px;}
.custom-colour{boarder:none; width:0px; visibility:hidden; float:left;}
.showLayer{display:block;}
.hideLayer{display:none;}
.range{margin-top:4px; float:left;}
.range-label{color: #f1f1f1; vertical-align:top; margin-top: 4px; float:left;}
.group-btn-mid{margin:0px; border-radius:0px; border-left: 1px solid #ccc; background-color: #8396a6;}
.group-btn-left{margin:0px; border-radius:3px 0 0 3px; background-color: #8396a6;}
.group-btn-right{margin:0px; border-radius:0 3px 3px 0; border-left: 1px solid #ccc; background-color: #8396a6;}
.group-btn-on{background-color: #415d77;}
.group-btn-off{}
.locked{background-image: linear-gradient(45deg, rgba(0,0,0,0.15) 25%, transparent 1%, transparent 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1) 75%, transparent 75%, transparent); background-size: 10px 10px;}
a{color:#123456; text-decoration: none;}
a:hover{color:#561234}
</style>
</head>

<body>
    <div id="topPanel">
        <div class="label">design</div>   
        <select id="designSelect" onchange="changeDesign(this.value)" style="margin-left:15px"></select>        
        <div class="label">zoom</div>      
        <button class="minus-btn" onclick="changeZoom(-10, 0, 0)">-</button>
        <div class="number-text" id="zoomText">100</div>
        <button class="plus-btn" onclick="changeZoom(10, 0, 0)">+</button> 

        <div class="label">pan left</div>      
        <button class="minus-btn" onclick="changeZoom(0, -10, 0)">-</button>
        <div class="number-text" id="panLeftText">100</div>
        <button class="plus-btn" onclick="changeZoom(0, 10, 0)">+</button> 

        <div class="label">pan up</div>      
        <button class="minus-btn" onclick="changeZoom(0, 0, -10)">-</button>
        <div class="number-text" id="panUpText">100</div>
        <button class="plus-btn" onclick="changeZoom(0, 0, 10)">+</button>          
        <button style="margin-left:8px;" onclick="resetZoomAndPanBtn()">reset zoom</button>
       
        <div class="label">bg colour</div> 
        <button id="backgroundColourPickerBtn" onclick="backgroundColourPicker.click()">-</button>
        <input class="custom-colour" id="backgroundColourPicker" type="color" oninput="changeBackgroundColor(this.value)"/>
        
        <div class="label">points</div>
        <div class="green-btn btn-on" onclick="changeDisplay(this, 'layerPoints')">&nbsp;</div>
        <div class="label">shapes</div>
        <div class="green-btn btn-on" onclick="changeDisplay(this, 'layerShapes')">&nbsp;</div>

        <div class="label">tools</div>
        <div class="green-btn btn-on" onclick="changeDisplay(this, 'layerTools')">&nbsp;</div>
        
        <div class="label">grid</div>
        <div class="green-btn btn-on" onclick="changeDisplay(this, 'layerGrid')">&nbsp;</div>
        
        <div class="label">background</div>
        <div class="green-btn btn-on" onclick="changeDisplay(this, 'layerBackground')">&nbsp;</div>
   
</div>
<div id="topInfoPanel">Place cursor here</div>
<div id="main">
    <div id="svgHolder">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1080 1080" id="designSvg" height="1080" width="1080" style="background-color:#123456;}">
            <defs>
                <pattern id="isoGridPattern" width="34.64101615137754" height="20" patternUnits="userSpaceOnUse" x="100" y="100">
                    <path id="isoGridPath" d="M 0 20 L0 0 L34.64101615137754 20 M0 20 L34.64101615137754 0 M17.32050807568877 0 L17.32050807568877 20" fill="none" stroke="#f1f1f1" stroke-width="0.5"></path>
                </pattern>               
            </defs>
            <g id="layerBackground" class="showLayer" transform="scale(1)"><image id="backgroundImage" href="" /></g>
            <g id="layerGrid" class="showLayer"></g>            
            <g id="layerShapes" class="showLayer"></g>
            <g id="layerPoints" class="showLayer"></g>
            <g id="layerPattern" class="showLayer"></g>
            <g id="layerRotatedPoints" class="showLayer"></g>
            <g id="layerCrop" class="showLayer"></g>
            <g id="layerTools" class="showLayer"></g>
            <g id="layerHud" class="showLayer">
                <path id="hudLineHorizontal" d="M0 0 L0 0" style="fill:none; stroke:#12345633; stroke-width:1;"></path>
                <path id="hudLineVertical" d="M0 0 L0 0" style="fill:none; stroke:#12345633; stroke-width:1;"></path>
            </g>
        </svg>       
     </div>
     
     <!--
     
<html>
    <head>
        <link href = "styling.css" rel = "stylesheet" type = "text/css"></link>
    </head>
    <body>
        <svg class = "button" expanded = "true" height = "100px" width = "100px">
            <circle cx = "50%" cy = "50%" r = "35%" stroke = "#000000" stroke-width = "10%" fill = "none"/>
            <circle class = "innerCircle" cx = "50%" cy = "50%" r = "25%" fill = "#000000">
              <animate attributeName="r" begin="0s" dur="1s" repeatCount="indefinite" from="5%" to="25%"/>
            </circle>
        </svg>
    </body>
</html>     
     
     -->
     
     
     <div id="controlPanel">     
        <div class="control-box cp-header" onclick="selectMode('pointContainer','points')"><div class="title">Points</div><div id="pointChevron" class="chevron up"></div></div>
        <div id="pointContainer" class="container">        
            <div class="control-box control-box-first"> 
                <div id="pointButtons"></div>
            </div> 
            <div class="control-box">
                <div class="label">move</div> 
                <button id="lockBtn" onclick="lockUnlockPoint()">lock</button>        
            </div>
            <div class="control-box">
                <div class="label">point</div> 
                <button onclick="clearPoint()">clear point</button>        
            </div>
            <div class="control-box">
                <div class="label">x</div>      
                <button class="minus-btn" onclick="changeX(-1, true)">-</button>
                <div class="number-text" id="xText" contenteditable="true">0</div>
                <button class="plus-btn" onclick="changeX(1, true)">+</button>
                <button onclick="changeX(xText.innerHTML, false)">update</button> 
            </div> 
            <div class="control-box">        
                <div class="label">y</div>      
                <button class="minus-btn" onclick="changeY(-1, true)">-</button>
                <div class="number-text" id="yText" contenteditable="true">0</div>
                <button class="plus-btn" onclick="changeY(1, true)">+</button>
                <button onclick="changeY(yText.innerHTML, false)">update</button>    
          </div>       
            <div class="control-box">
                <div class="label">angle</div>      
                <button class="minus-btn" onclick="changeAngle(-1, true)">-</button>
                <div class="number-text" id="angleText" contenteditable="true">0</div>
                <button class="plus-btn" onclick="changeAngle(1, true)">+</button>
                <button onclick="changeAngle(angleText.innerHTML, false)">update</button>
          </div>       
            <div class="control-box">
                <div class="label">angle presets</div>
                <div id="anglePresets">    
                    <button onclick="changeAngle(0, false)">0</button>
                    <button onclick="changeAngle(12.5, false)">12.5</button>
                    <button onclick="changeAngle(15, false)">15</button>
                    <button onclick="changeAngle(30, false)">30</button>
                    <button onclick="changeAngle(60, false)">60</button>
                </div>    
            </div> 
            <div class="control-box">        
                <div class="label">length</div>      
                <button class="minus-btn" onclick="changeLength(-1, true)">-</button>
                <div class="number-text" id="lengthText" contenteditable="true">0</div>
                <button class="plus-btn" onclick="changeLength(1, true)">+</button>
                <button onclick="changeLength(lengthText.innerHTML, false)">update</button>    
            </div>           
            <div class="control-box">
                <div class="label">rotation</div>      
                <button class="minus-btn" onclick="changeRotation(-1, true)">-</button>
                <div class="number-text" id="rotationText">0</div>
                <button class="plus-btn" onclick="changeRotation(1, true)">+</button>
                <div id="rotationBtns"></div>
            </div>     
            <div class="control-box">  
                <div class="label">angles</div>   
                <div id="rotationInfo" style="color:#f1f1f1; float:left; padding-top:4px"></div>
            </div> 
            <div class="control-box">
                <div class="label">center point</div>
                <select id="connectSelect" onchange="changeConnect(this.value)"></select>
                <button onclick="changeConnect(0)">first</button>
                <button onclick="changeConnect('previous')">previous</button>
                <button onclick="changeConnect('self')">self</button>            
            </div>            
            <div class="control-box">
                <div class="label">rounding</div>      
                <button class="minus-btn" onclick="changePointProperty('rounding', -0.1, true, 'roundingText')">-</button>
                <div class="number-text" id="roundingText">0</div>
                <button class="plus-btn" onclick="changePointProperty('rounding', 0.1, true, 'roundingText')">+</button>
            </div> 
            <div class="control-box">
                <div class="label">rounding weight</div>      
                <button class="minus-btn" onclick="changePointProperty('roundingWeight', -1, true, 'roundingWeightText')">-</button>
                <div class="number-text" id="roundingWeightText">0</div>
                <button class="plus-btn" onclick="changePointProperty('roundingWeight', 1, true, 'roundingWeightText')">+</button>
            </div>        
            
            
            <div class="control-box">
                <div class="label">pair points</div>
                <select id="pairPointsSelect" onchange="changePointProperty('pair', this.value, false, null)"></select>           
            </div>            
            <div class="control-box">
                <div class="label">shape opacity</div>
                <input id="shapeOpacity1" type="range" min="0" max="100" value="25" class="range" oninput="changeShapeOpacity(this.value)" />
                <div id="shapeOpacityText1" class="range-label">25%</div>    
            </div>            
            <div class="control-box">
                <div class="label">shape type</div>
                <button class="make-btn group-btn-left" onclick="makeShapeBtn()">make</button>
                <button class="rotate-btn group-btn-mid" onclick="rotateShapesBtn()">rotate</button> 
                <button class="repeat-btn group-btn-mid" onclick="repeatShapesBtn()">repeat</button>  
                <button class="radial-btn group-btn-right" onclick="radialRepeatShapesBtn()">radial</button>  
            </div>             
            <div class="control-box control-box-last">
                <div class="label">snap type</div>
                <button class="point-btn group-btn-left" onclick="changeSnap('point')">point</button>
                <button class="shape-btn group-btn-mid" onclick="changeSnap('shape')">repeated shape</button> 
                <button class="tool-btn group-btn-right" onclick="changeSnap('tool')">tool</button>  
                <button class="grid-btn group-btn-right" onclick="changeSnap('grid')">grid</button>  
            </div> 
        </div>
        <div class="control-box cp-header" onclick="selectMode('shapeContainer','shapes')"><div class="title">Shapes</div><div id="shapeChevron" class="chevron down"></div></div>
        <div id="shapeContainer" class="container">
            <div class="control-box control-box-first" id="shapeButtons"></div> 
            <div class="control-box">
                <div class="label">lock shape</div> 
                <button id="lockShapeBtn" onclick="lockUnlockShape()">lock</button>        
            </div>            
            <div class="control-box">
                <div class="label">shape data</div> 
                <textarea id="shapeData" cols="20" rows="4"></textarea> 
            </div>
            <div class="control-box">
                <div class="label">shape data</div> 
                <button onclick="updateShape()" style="margin-left:5px">update</button>
                <button onclick="clearShapeBtn()">clear</button> 
                <button onclick="removeLastShapeBtn()">remove last</button>    
            </div>
            <div class="control-box">     
                <div class="label">shape rotate</div>      
                <button class="minus-btn" onclick="changeShapeRotation(-1, true)">-</button>
            <div class="number-text" id="shapeRotationText">1</div>
                <button class="plus-btn" onclick="changeShapeRotation(1, true)">+</button>            
                <button onclick="changeShapeRotation(1, false)">1</button>
                <button onclick="changeShapeRotation(3, false)">3</button>
                <button onclick="changeShapeRotation(6, false)">6</button>
                <button onclick="changeShapeRotation(12, false)">12</button>            
            </div>
            <div class="control-box" style="color:#f1f1f1;">
                <div class="label">skip rotated</div> 
            </div>
            <div class="control-box" id="skipBtnContainer"></div>
            <div class="control-box">  
                <div class="label">fill colour</div> 
                <button id="shapeFillPickerBtn" onclick="shapeFillPicker.click()">-</button>
                <!-- <input id="shapeFillPicker" class="custom-colour" type="color" oninput="changePropValue('shape', 'fill', this.value, 'colour-input', 'shapeFillPicker', false)" /> -->
                <input id="shapeFillPicker" class="custom-colour" type="color" oninput="changeShapeProperty('fill', this.value, false)" />                
            </div>            
            <div class="control-box"> 
                <div class="label">fill opacity</div>      
                <button class="minus-btn" onclick="changeShapeProperty('fillOpacity', -10, true)">-</button>
                <div class="number-text" id="fillOpacityText" contenteditable="true">100</div>
                <button class="plus-btn" onclick="changeShapeProperty('fillOpacity', 10, true)">+</button>
            </div>            
            <div class="control-box"> 
                <div class="label">stroke colour</div> 
                <button id="shapeStrokePickerBtn" onclick="shapeStrokePicker.click()">-</button>
                <!-- <input id="shapeStrokePicker" class="custom-colour" type="color" oninput="changePropValue('shape', 'stroke', this.value, 'colour-input', 'shapeStrokePicker', false)" />-->
                <input id="shapeStrokePicker" class="custom-colour" type="color" oninput="changeShapeProperty('stroke', this.value, false)" />
            </div>
            <div class="control-box">
                <div class="label">stroke opacity</div>      
                <button class="minus-btn" onclick="changeShapeProperty('strokeOpacity', -10, true)">-</button>
                <div class="number-text" id="strokeOpacityText" contenteditable="true">100</div>
                <button class="plus-btn" onclick="changeShapeProperty('strokeOpacity', 10, true)">+</button>
            </div>            
            <div class="control-box">
                <div class="label">us shape opacity</div>
                <input id="shapeOpacity2" type="range" min="0" max="100" value="25" class="range" oninput="changeUnselectedShapeOpacity(this.value)" />
                <div id="shapeOpacityText2" class="range-label">25%</div>    
            </div>            
            <div class="control-box control-box-last">
                <div class="label">shape type</div>
                <button class="make-btn group-btn-left" onclick="makeShapeBtn()">make</button>
                <button class="rotate-btn group-btn-mid" onclick="rotateShapesBtn()">rotate</button> 
                <button class="repeat-btn group-btn-mid" onclick="repeatShapesBtn()">repeat</button>  
                <button class="radial-btn group-btn-right" onclick="radialRepeatShapesBtn()">radial</button>  
            </div> 
        </div>         
        <div class="control-box cp-header" onclick="selectMode('patternContainer','patterns')"><div class="title">Pattern</div><div id="patternChevron" class="chevron down"></div></div>
        <div id="patternContainer" class="container">             
            <div class="control-box control-box-first">
                <div class="label">pattern points</div>
                <div id="patternButtons"></div>
            </div>
            <div class="control-box">     
                <div class="label">repeat x</div>      
                <button class="minus-btn" onclick="changeRepeatX(-1, true)">-</button>
                <div class="number-text" id="repeatXText">0</div>
                <button onclick="changeRepeatX(1, true)">+</button>          
            </div>
            <div class="control-box">     
                <div class="label">repeat y</div>      
                <button class="minus-btn" onclick="changeRepeatY(-1, true)">-</button>
                <div class="number-text" id="repeatYText">0</div>
                <button onclick="changeRepeatY(1, true)">+</button>          
            </div>
            <div class="control-box">  
            <div class="label">repeat</div>  
                <button onclick="repeatShapesBtn()">repeat shapes</button>
            </div>
            <!-- <div class="control-box"> 
                <div class="label">snap point</div>             
                <input id="patternSnapText" type="text" placeholder="a1" style="width:40px" />
            </div> -->            
            <div class="control-box"> 
                <div class="label">snap point</div>             
                <button onclick="selectSnapsBtn()">select snap points</button>
            </div>           
            <div class="control-box"> 
                <div class="label">radial repeat</div> 
                <button onclick="radialRepeatShapesBtn()">repeat shapes</button>
            </div>
            <div class="control-box control-box-last">
                <div class="label">snap type</div>
                <button class="point-btn group-btn-left" onclick="changeSnap('point')">point</button>
                <button class="shape-btn group-btn-mid" onclick="changeSnap('shape')">repeated shape</button> 
                <button class="tool-btn group-btn-right" onclick="changeSnap('tool')">tool</button>  
                <button class="grid-btn group-btn-right" onclick="changeSnap('grid')">grid</button>  
            </div>          
        </div>        
        <div class="control-box cp-header" onclick="selectMode('toolContainer','tools')"><div class="title">Tools</div><div id="toolChevron" class="chevron down"></div></div>
        <div id="toolContainer" class="container">
        <div class="control-box control-box-first">
            <div class="label">divisions</div>      
            <button onclick="makeTool('straightDivision')">straight division</button>
            <button class="minus-btn" onclick="changeToolValue('straightDivision', 'division', -1, 'divisionText', true)">-</button>
            <div class="number-text" id="divisionText">0</div>
            <button onclick="changeToolValue('straightDivision', 'division', 1, 'divisionText', true)">+</button>
            </div>
            <div class="control-box">
                <div class="label">intersect</div>
                <button onclick="makeTool('intersectLines')">intersect lines</button>
                <button onclick="addIntersectLinesBtn('intersectLines')">+</button>                
                <button class="minus-btn" onclick="changeToolValue('intersectLines', 'extension', -10, 'extensionText', true)">-</button>
                <div class="number-text" id="extensionText">0</div>
                <button onclick="changeToolValue('intersectLines', 'extension', 10, 'extensionText', true)">+</button>                 
            </div>
            <div class="control-box">
                <div class="label">centroid</div>
                <button onclick="makeTool('centroid')">centroid</button>
                <button class="minus-btn"onclick="changeToolValue('centroid', 'sides', -1, 'changeCentroidQtyTxt', true)">-</button>
                <div id="changeCentroidQtyTxt" class="number-text">0</div>
                <button class="plus-btn"onclick="changeToolValue('centroid', 'sides', 1, 'changeCentroidQtyTxt', true)">+</button>                
            </div>
<!--
            <div class="control-box">
                <div class="label">pattern snap</div>
                <button onclick="makeTool('snapPattern')">point to snap</button>
                <input id="selectedPoint" type="text" style="width:40px">
                <button onclick="findSnapBtn()">find snap</button>         
            </div>   
-->          
            <div class="control-box">
                <div class="label">internal angle</div>
                <button onclick="makeTool('internalAngle')">internal angle</button>
                <input id="internalAngleText" type="text" style="width:40px" value="45">
                <button onclick="makeTool('internalAngle')">update</button>         
            </div>            
            <div class="control-box">
                <div class="label">get angle</div>
                <button onclick="makeTool('getAngle')">get angle</button>
                <input id="getAngleText" type="text" style="width:40px" value="45">
                <button onclick="makeTool('getAngle')">update</button>         
            </div>   
            <div class="control-box">
                <div class="label">get measurement</div>
                <button onclick="makeTool('getMeasurement')">get measurement</button>    
            </div>      
            <div class="control-box">
                <div class="label">poly star</div>
                <button onclick="makeTool('polystar')">poly star</button>
                <button class="minus-btn"onclick="changeToolValue('polystar', 'sides', -1, 'changePolyStarQtyTxt', true)">-</button>
                <div id="changePolyStarQtyTxt" class="number-text">0</div>
                <button class="plus-btn"onclick="changeToolValue('polystar', 'sides', 1, 'changePolyStarQtyTxt', true)">+</button>                
            </div>
            
            <div class="control-box">
                <div class="label">tool center</div>
                <button class="plus-btn"onclick="centerToolBtn(true)">center tool</button>                
            </div>
            <div class="control-box">
                <div class="label">snap type</div>
                <button class="point-btn group-btn-left" onclick="changeSnap('point')">point</button>
                <button class="shape-btn group-btn-mid" onclick="changeSnap('shape')">repeated shape</button> 
                <button class="tool-btn group-btn-right" onclick="changeSnap('tool')">tool</button>  
                <button class="grid-btn group-btn-right" onclick="changeSnap('grid')">grid</button>  
            </div> 
            <div class="control-box control-box"> 
                <div class="label">handle size</div> 
                <button class="minus-btn"onclick="changePropValue('appData', 'guideHandleSize', -1,'changeGuideHandleTxt', null, true)">-</button>
                <div id="changeGuideHandleTxt" class="number-text">0</div>
                <button class="plus-btn"onclick="changePropValue('appData', 'guideHandleSize', 1, 'changeGuideHandleTxt', null, true)">+</button>
            </div> 
            <div class="control-box"> 
                <div class="label">guide colour</div> 
                <button id="guideColourInputBtn" onclick="guideColourInput.click()"></button>
                <input id="guideColourInput" class="custom-colour" type="color" oninput="changePropValue('appData', 'guideColour', this.value, 'colour-input', 'guideColourInput', false)"/>
            </div>        
        </div>        
    <div class="control-box cp-header" onclick="selectMode('gridContainer','tools')"><div class="title">Grid</div><div id="gridChevron" class="chevron down"></div></div>
       




       <div id="gridContainer" class="container">    
                <div class="control-box control-box-first">
                    <div class="label">select grid</div>
                    <button class="isometric-btn group-btn-left group-btn-on" onclick="makeTool('isometricGrid')">isometric grid</button>
                    <button class="rectangular-btn group-btn-right" onclick="makeTool('rectangularGrid')">rectangular grid</button>
                </div>   
            <div id="isometricGridContainer" class="show">
                <div class="control-box">
                    <div class="label">isometric grid</div>
                    <button onclick="makeTool('isometricGrid')">make grid</button>
                </div>            
                <div class="control-box">
                    <div class="label">i tri height</div>
                    <button class="minus-btn" onclick="changeToolValue('isometricGrid', 'triangleHeight', -1, 'triangleHeightText', true)">-</button>
                    <div class="number-text" id="triangleHeightText">0</div>
                    <button class="plus-btn" onclick="changeToolValue('isometricGrid', 'triangleHeight', 1, 'triangleHeightText', true)">+</button> 
                </div>
                <div class="control-box">
                    <div class="label">i rotation</div>
                    <div class="number-text" id="gridRotationText">0</div>
                    <button id="isoGridRotation0" class="group-btn-left" onclick="changeToolValue('isometricGrid', 'rotation', 0, 'gridRotationText', false)">0</button>
                    <button id="isoGridRotation30" class="group-btn-right" onclick="changeToolValue('isometricGrid', 'rotation', 30, 'gridRotationText', false)">30</button>                 
                </div>  
                <div class="control-box">
                    <div class="label">i x repeat</div>
                    <button class="minus-btn" onclick="changeToolValue('isometricGrid', 'xRepeat', -1, 'xRepeatIsoText', true)">-</button>
                    <div class="number-text" id="xRepeatIsoText">0</div>
                    <button onclick="changeToolValue('isometricGrid', 'xRepeat', 1, 'xRepeatIsoText', true)">+</button> 
                </div>             
                <div class="control-box">
                    <div class="label">i y repeat</div>
                    <button class="minus-btn" onclick="changeToolValue('isometricGrid', 'yRepeat', -1, 'yRepeatIsoText', true)">-</button>
                    <div class="number-text" id="yRepeatIsoText">0</div>
                    <button onclick="changeToolValue('isometricGrid', 'yRepeat', 1, 'yRepeatIsoText', true)">+</button> 
                </div>             
                <div class="control-box">
                    <div class="label">i x start</div>
                    <button class="minus-btn" onclick="changeToolValue('isometricGrid', 'xStart', -1, 'xStartIsoText', true)">-</button>
                    <div class="number-text" id="xStartIsoText">0</div>
                    <button onclick="changeToolValue('isometricGrid', 'xStart', 1, 'xStartIsoText', true)">+</button> 
                </div>
                <div class="control-box">
                    <div class="label">i y start</div>
                    <button class="minus-btn" onclick="changeToolValue('isometricGrid', 'yStart', -1, 'yStartIsoText', true)">-</button>
                    <div class="number-text" id="yStartIsoText">0</div>
                    <button onclick="changeToolValue('isometricGrid', 'yStart', 1, 'yStartIsoText', true)">+</button> 
                 </div>             
                <div class="control-box"> 
                <div class="label">grid colour</div> 
                <button id="gridColourPickerBtn" onclick="gridColourPicker.click()">-</button>
                <input id="gridColourPicker" class="custom-colour" type="color" oninput="changeToolValue('isometricGrid', 'colour', this.value, 'gridColourPicker', false)" />
                <!--<input id="gridColourPicker" class="custom-colour" type="color" oninput="changePropValue('isometricGrid', 'colour', this.value, 'colour-input', 'gridColourPicker', false)" />-->
                </div>
            </div>            
            <div id="rectangularGridContainer" class="hide">
                <div class="control-box">
                    <div class="label">rectangular grid</div>
                    <button onclick="makeTool('rectangularGrid')">rectangular grid</button>
                </div>
                
                <div class="control-box">
                    <div class="label">constrian</div>
                    <button onclick="changeToolValue('rectangularGrid', 'constrain', true, 'rectangularxRepeatText', false)">yes</button>
                    <button onclick="changeToolValue('rectangularGrid', 'constrain', false, 'rectangularxRepeatText', false)">no</button>
                </div>  
                <div class="control-box">
                    <div class="label">r x repeat</div>
                    <button class="minus-btn" onclick="changeToolValue('rectangularGrid', 'xRepeat', -1, 'rectangularxRepeatText', true)">-</button>
                    <div class="number-text" id="rectangularxRepeatText">0</div>
                    <button class="plus-btn" onclick="changeToolValue('rectangularGrid', 'xRepeat', 1, 'rectangularxRepeatText', true)">+</button> 
                </div> 
                <div class="control-box">
                    <div class="label">r y repeat</div>
                    <button class="minus-btn" onclick="changeToolValue('rectangularGrid', 'yRepeat', -1, 'rectangularyRepeatText', true)">-</button>
                    <div class="number-text" id="rectangularyRepeatText">0</div>
                    <button class="plus-btn" onclick="changeToolValue('rectangularGrid', 'yRepeat', 1, 'rectangularyRepeatText', true)">+</button> 
                </div>     
                <div class="control-box"> 
                <div class="label">r grid colour</div> 
                <button id="rectGridColourPickerBtn" onclick="rectGridColourPicker.click()">-</button>
                <input id="rectGridColourPicker" class="custom-colour" type="color" oninput="changeToolValue('rectangularGrid', 'colour', this.value, 'rectGridColourPicker', false)" />
                </div>
            </div>
            <div class="control-box control-box-last"> 
            <div class="label">hide grid</div> 
            <button onclick="hideGrid()">hide grid</button>
            </div>           
        </div>
            <div class="control-box cp-header" onclick="selectMode('backgroundContainer','background')"><div class="title">Background</div><div id="backgroundChevron" class="chevron down"></div></div>
            <div id="backgroundContainer" class="container">
            <div class="control-box control-box-first"> 
                <div class="label">bg image</div>
                <input id="fileData" type="text" style="width:120px" placeholder="background image">
                <button onclick="fileSelector.click()">select</button>  
                <input style="display:none;" id="fileSelector" type="file" onchange="getImageFileName(this.value)"/>
                <button onclick="updateDesignBackgroundImageBtn()">change</button> 
            </div> 
            <div class="control-box">  
                <div class="label">bg zoom</div>                 
                <input id="backgroundZoomRange" type="range" min="10" max="400" value="100" class="range" oninput="changeBackgroundZoom(this.value)" />
                <div id="backgroundZoomText" class="range-label">100%</div>
            </div>
            <div class="control-box">  
                <div class="label">bg opacity</div>                 
                <input id="backgroundOpacityRange" type="range" min="0" max="100" value="80" class="range" oninput="changeBackgroundOpacity(this.value)" />
                <div id="backgroundOpacityText" class="range-label">80%</div>
            </div>    
            <div class="control-box control-box-last">  
                <div class="label">bg rotation</div>                 
                <input id="backgroundRotationRange" type="range" min="-50" max="50" value="0" class="range" oninput="changeBackgroundRotation(this.value)" />
                <div id="backgroundRotationText" class="range-label">0</div>
            </div>   
        </div>
        <div class="control-box cp-header" onclick="selectMode('cropContainer','crop')"><div class="title">Crop</div><div id="cropChevron" class="chevron down"></div></div>
        <div id="cropContainer" class="container">
        <div class="control-box">  
            <div class="label">crop width</div>                 
            <button class="minus-btn" onclick="changeOutlineWidth(-1, true)">-</button>
            <div class="number-text" id="outlineWidthText">0</div>
            <button onclick="changeOutlineWidth(1, true)">+</button>  
            <button onclick="cropShapesBtn()">crop shapes</button>
            
        </div>
        <div class="control-box">
            <div class="label">reset crop</div>
            <button onclick="resetCropBtn()">reset</button>
        </div>
        <div class="control-box">
            <div class="label">clipboard</div>
            <button onclick="copySvgToClipboard(layerCrop, true)">copy cropped sorted</button>
            <button onclick="copySvgToClipboard(layerCrop, false)">copy cropped</button>
        </div> 
        <div class="control-box control-box-last"> 
            <div class="label">crop outline</div> 
            <button id="cropOutlineColourBtn" onclick="cropOutlineColour.click()">-</button>
            <!--<input id="cropOutlineColour" class="custom-colour" type="color" oninput="changeCropOutline(this.value)"/>-->
            <input id="cropOutlineColour" class="custom-colour" type="color" oninput="changePropValue('design', 'outlineColour', this.value, 'colour-input', 'cropOutlineColour', false)"/>
        </div>
    </div> 
     <div class="control-box cp-header" onclick="selectMode('designContainer','designs')"><div class="title">Design</div><div id="designChevron" class="chevron down"></div></div>
     <div id="designContainer" class="container">  
         <div class="control-box">
            <div class="label">add</div>
            <input id="designName" type="text"  style="width:120px" placeholder="design name"/>
            <button onclick="addNewDesignBtn(designName.value)">add new</button>            
        </div>         
        <div class="control-box">  
            <div class="label">update</div>
            <input id="designNameUpdateText" type="text"  style="width:120px" placeholder="design name"/>
            <button onclick="updateDesignTitleBtn()">update</button>
        </div>         
         <div class="control-box">
            <div class="label">import pspn</div>
            <button onclick="fileSelectorPspn.click()">import pspn file</button>  
            <input style="display:none;" id="fileSelectorPspn" type="file" onchange="getPspnText(event, this.value)"/>
         </div>        
         <div class="control-box">   
            <div class="label">curve articulation</div>
            <button class="minus-btn"onclick="changePropValue('design', 'articulateCurve', -1,'articulateCurveTxt', null, true)">-</button>
            <div id="articulateCurveTxt" class="number-text">0</div>
            <button class="plus-btn"onclick="changePropValue('design', 'articulateCurve', 1, 'articulateCurveTxt', null, true)">+</button>            
         </div>
         <div class="control-box">   
            <div class="label">articulation on</div>
            <button class="minus-btn"onclick="changePropValue('design', 'isArticulated', false,'articulateCurveTxt', null, false)">no</button>
            <button class="plus-btn"onclick="changePropValue('design', 'isArticulated', true, 'articulateCurveTxt', null, false)">yes</button>            
         </div>
         
         <div class="control-box">   
            <div class="label">duplicate</div>
            <button onclick="duplicateDesignBtn()">duplicate</button>
         </div>
         <div class="control-box control-box-last">   
            <div class="label">delete</div>
            <button onclick="deleteDesignBtn()">delete</button>
         </div>     
     </div>     
     <div class="control-box cp-header" onclick="selectMode('exportContainer','export')"><div class="title">Export</div><div id="exportChevron" class="chevron down"></div></div>
     <div id="exportContainer" class="container">
     <div class="control-box control-box-first"><div class="label">svg</div><button onclick="saveSvg()">save svg</button></div>
     <div class="control-box"><div class="label">png</div><button onclick="savePng()">save png</button></div>
     <div class="control-box"><div class="label">pspn</div><button onclick="exportPspnDataBtn()">export pspn data</button></div>
     <div class="control-box"><div class="label">code</div><button onclick="exportCodeBtn()">export code</button></div>
     <div class="control-box"><div class="label">cropped shapes</div><button onclick="exportShapesBtn()">export shapes</button></div>
     <div class="control-box"><div class="label">formula</div><button onclick="exportShapesBtn()">export formula</button></div>
     <div class="control-box control-box-last"><div class="label">clipboard</div>
     <button onclick="copySvgToClipboard(layerShapes, true)">copy shapes sorted</button>
     <button onclick="copySvgToClipboard(layerShapes, false)">copy shapes</button>
     </div>

     </div>
    </div>
    </div>
    <div id="tooltip"></div>
    <div><canvas id="svgCanvas"></canvas></div>
</body>

<script id="kevin"  type='text/javascript'>
////////////////////////////////////////Variables Start//////////////////////////////////////////
const svgns = "http://www.w3.org/2000/svg";
const designSvg = document.getElementById('designSvg');
//const isTouchDevice = "ontouchstart" in document.documentElement;
const angleText = document.getElementById('angleText');
const backgroundOpacityText = document.getElementById('backgroundOpacityText');
const connectSelect = document.getElementById('connectSelect');
const designSelect = document.getElementById('designSelect');
const layerPoints = document.getElementById('layerPoints');
const layerRotatedPoints = document.getElementById('layerRotatedPoints');
const layerShapes = document.getElementById('layerShapes');
const lengthText = document.getElementById('lengthText');
const pointButtons = document.getElementById('pointButtons');
const patternButtons = document.getElementById('patternButtons');
const repeatXText = document.getElementById('repeatXText');
const repeatYText = document.getElementById('repeatYText');
const rotationText = document.getElementById('rotationText');
const shapeButtons = document.getElementById('shapeButtons');
const shapeRotationText = document.getElementById('shapeRotationText');
const xText = document.getElementById('xText');
const yText = document.getElementById('yText');
const zoomText = document.getElementById('zoomText');
const hudLineHorizontal = document.getElementById('hudLineHorizontal');
const hudLineVertical = document.getElementById('hudLineVertical');
const hexColourList = ["#FE2712","#FC600A","#FB9902","#FCCC1A","#cccc00","#B2D732","#66B032","#347C98","#0247FE","#4424D6","#8601AF","#C21460"];
const hexOpacityList = ["00", "19", "33", "4C", "66", "7F", "99", "B2", "CC" ,"E5", "FF"];
const letters = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","aa","ab","ac","ad","ae","af"];
////////////////////////////////////////Variables End//////////////////////////////////////////
////////////////////////////////////////Objects Start//////////////////////////////////////////////
function Point(x, y, connect, angle, startAngle, length, calculatedLength, rotation, letter){
    this.letter = getNextLetter(); //get letter function
    this.x = niceNum(x) || 0;
    this.y = niceNum(y) || 0;
    this.connect = connect || 0;
    this.pair = -1;
    this.angle = angle || 0;
    this.startAngle = startAngle || 0;
    this.length =  length || 12; 
    this.calculatedLength = calculatedLength || 1;
    this.rotation = rotation || 12 ;
    this.isLocked = false;
    this.rounding = 0;
    this.roundingWeight = 0;
}

function SvgPoint(layer, typer, x, y, x1, y1, x2, y2, radiusX, radiusY, rotation, arc, sweepFlag){
    //x1 = (typeof x1 !== 'undefined') ? x1:1;
    this.layer = layer;
    this.t = typer;
    this.x = niceNum(x) || 0;
    this.y = niceNum(y) || 0;
    this.x1 = niceNum(x1) || 0;
    this.y1 = niceNum(y1) || 0;
    this.x2 = niceNum(x2) || 0;
    this.y2 = niceNum(y2) || 0;
    this.radiusX = radiusX || 0;
    this.radiusY = radiusY || 0;
    this.rotation = rotation || 0;
    this.arc = arc || 0;
    this.sweepFlag = sweepFlag || 0;
}

function Shape(){
    //this will be the next colour in the list
    let colour = getHexColour(getCurrentDesign().shapes.length);
    this.data = [];
    this.rotation = 6;
    this.skip = [];
    this.fill = colour;
    this.stroke = colour;
    this.fillOpacity = 30;
    this.strokeOpacity = 30;
    this.isLocked = false;
 }

function Design(title, fileName){
    this.title = title || "";
    this.image = fileName;
    this.xRepeat = 2; 
    this.yRepeat = 2;
    this.points = [];
    this.cropPoints = [{x:100, y:100},{x:800, y:800}];
    this.patternPoints = [{x:100, y:100},{x:200, y:200}];
    this.shapes = []; 
    this.bgOpacity = 100; 
    this.bgZoom = 100;
    this.bgRotate = 0;
    this.bgPosition = {x:0, y:0};
    this.backgroundColour = "#f1f1f1";
    this.zoom = 100;
    this.panLeft = 0;
    this.panUp = 0;
    this.outlineWidth = 2;
    this.outlineColour = "#f1f1f1";
    this.tools = []; 
    this.shapeRenderType = "repeat"
    this.articulateCurve = 2;
    this.isArticulated = false;
}

const tools = [
        {name:"straightDivision", division:3, points:[{x:10, y:10}, {x:50, y:50}], nodes:[]}, 
        {name:"intersectLines", points:[{x:10, y:10}, {x:50, y:50}], nodes:[], extension:100}, 
        {name:"centroid", sides:5, points:[{x:10, y:10}, {x:100, y:10}, {x:100, y:100}, {x:10, y:100}], nodes:[{x:200, y:200}]},
        {name:"isometricGrid", xStart:100, yStart:100, colour:"#c1c1c1", triangleHeight:20, xRepeat:14, yRepeat:14, rotation:30, points:[{x:100, y:100},{x: 505, y: 437.5}], nodes:[{x:100, y:100},{x: 505, y: 437.5}]},
        {name:"internalAngle", angle:45, points:[{x:100, y:100}, {x:200, y:200}, {x:0, y:0}], nodes:[]},
        {name:"getAngle", innerAngle:45, outerAngle:215, points:[{x:10, y:50}, {x:100, y:100}, {x:100, y:50}]},
        {name:"rectangularGrid", xStart:100, yStart:100, colour:"#c1c1c1", height:20, width:20, xRepeat:14, yRepeat:14, points:[{x: 100, y: 100}, {x: 380, y: 380}], constrain:false},
        {name:"getMeasurement", innerAngle:45, outerAngle:215, points:[{x:10, y:10}, {x:100, y:100}]},
        {name:"test", innerAngle:45, outerAngle:215, points:[{x:10, y:10}, {x:100, y:100}]},
        {name:"polystar", sides:5, centroid:{x:10, y:10}, points:[{x:10, y:10}, {x:100, y:10}, {x:100, y:100}, {x:10, y:100}], nodes:[{x:200, y:200}]},        
];

const appData = new function(){
    this.designIndex = 0;      
    this.designs = [new Design("first_design")];
    this.guideColour = "#125634";
    this.guideHandleSize = 2;
}

const sessionData = new function(){
    this.rotatedPoints = []; 
    this.rotatedShapes = [];     
    this.drag = false; 
    this.updating = false;
    this.patternSnapOffset = {x:0, y:0};
    this.pointType = ""; 
    this.mode = "points"; 
    this.pointIndex = 0; 
    this.cropPointIndex = 0; 
    this.patternPointIndex = 0; 
    this.shapeIndex = 0;   
    this.toolIndex = 0; 
    this.toolPointIndex = 0;
    this.toolNameList = [];    
    this.shapeOpacity = 25;
    this.unselectedShapesOpacity = 20;
    this.shapeRenderType = "rotate"; //make, rotate, repeat
    //snap points
    this.snapMode = ["tool"];
    this.snapPoints = [];
    this.pointSnapPoints = [];
    this.repeatedShapeSnapPoints = []; //is used?
    this.toolSnapPoints = [];
    this.gridSnapPoints = [];
    this.selectedSnaps = [];
    this.selectedSnapsIsSelecting = false;
    this.svgWidth = 100;
    this.svgHeight = 100;
    this.pairedPoint = -1;
}
////////////////////////////////////////Objects End//////////////////////////////////////////////
////////////////////////////////////////Calculate Point Start//////////////////////////////////////////
function rotateAroundPoint(centerOfRotation, degrees, length){
    var xRot = centerOfRotation.x + (Math.cos(Math.PI/180 * degrees)*length);
    var yRot = centerOfRotation.y + (Math.sin(Math.PI/180 * degrees)*length);
    return {x:xRot,y:yRot};
}

function rotatePoint(centerOfRotation, pointToRotate, degrees){
    var length = calculateDistance(centerOfRotation, pointToRotate, true); //find line distance
    var angle = lineAngle(centerOfRotation, pointToRotate, true); //find current angle
    var xRot = centerOfRotation.x + (Math.cos(Math.PI/180 * (degrees+angle))*length);
    var yRot = centerOfRotation.y + (Math.sin(Math.PI/180 * (degrees+angle))*length);
    return {x:niceNum(xRot),y:niceNum(yRot)};
}

function getPolygonCentroid(ptsOriginal) {
    pts = Object.create(ptsOriginal);
    var first = pts[0]
    var last = pts[pts.length-1];
    //////console.log(first, last, pts, pts.length-1)
    if (first.x != last.x || first.y != last.y) pts.push(first);
    var twicearea=0,
    x=0, y=0,
    nPts = pts.length,
    p1, p2, f;
    for(var i=0, j=nPts-1; i<nPts; j=i++){
        p1 = pts[i]; p2 = pts[j];
        f = p1.x*p2.y - p2.x*p1.y;
        twicearea += f;
        x += ( p1.x + p2.x ) * f;
        y += ( p1.y + p2.y ) * f;
    }
    f = twicearea * 3;
    return { x:x/f, y:y/f };
}

//improved line intersect - includes is the intersection along the segments
function lineIntersect(pos1, pos2, pos3, pos4, alongSegment){
  // Check if none of the lines are of length 0
	if ((pos1.x === pos2.x && pos1.y === pos2.y) || (pos3.x === pos4.x && pos3.y === pos4.y)) {
		return false;
	}
	var denominator = ((pos4.y - pos3.y) * (pos2.x - pos1.x) - (pos4.x - pos3.x) * (pos2.y - pos1.y));
  // Lines are parallel
	if (denominator === 0) {
		return false;
	}
	let ua = ((pos4.x - pos3.x) * (pos1.y - pos3.y) - (pos4.y - pos3.y) * (pos1.x - pos3.x)) / denominator;
	let ub = ((pos2.x - pos1.x) * (pos1.y - pos3.y) - (pos2.y - pos1.y) * (pos1.x - pos3.x)) / denominator;
  
    //is the intersection along the segments
    if(alongSegment==true){
        //console.log("in:", alongSegment)
        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
            return false;
        }
    }
  // Return a object with the x and y coordinates of the intersection
	let x = pos1.x + ua * (pos2.x - pos1.x);
	let y = pos1.y + ua * (pos2.y - pos1.y);
	return {x, y};
}

function calculateDistance(pos1,pos2,positiveOnly){
    var a = Number(pos1.x) - Number(pos2.x);
    var b = Number(pos1.y) - Number(pos2.y);
    var ans = Math.sqrt(a*a + b*b)
    if(positiveOnly){ans = Math.abs(ans)}
    if(isNaN(ans)){ans=10000;}
    return ans;
}

function lineAngle(pos1, pos2, positiveOnly){
	var deltaX = pos2.x - pos1.x ;
	var deltaY = pos2.y - pos1.y;
	var rad = Math.atan2(deltaY, deltaX); // In radians
	var deg = rad * (180 / Math.PI); // In degrees
	if(positiveOnly){
        if(deg<0){
            deg+=360}
        ;
    } 
    return Number(deg.toFixed(5));
}

function findPointOnLine(pos1,pos2,percent){
	var xPos = pos1.x+((pos2.x-pos1.x)*percent);
	var yPos = pos1.y-((pos1.y-pos2.y)*percent);
	return {x:xPos,y:yPos};    
}
////////////////////////////////////////Calculate Point Start//////////////////////////////////////////
////////////////////////////////////////SVG Functions Start//////////////////////////////////////////
function createCircle(id, pos, r, fill, stroke, strokeWidth, layer, className){
    var circle = document.createElementNS(svgns, 'circle');
    if(id!==null) circle.setAttributeNS(null, 'id', id);
    if(className!=null) circle.setAttributeNS(null, 'class', className);
    circle.setAttributeNS(null, 'cx', pos.x);
    circle.setAttributeNS(null, 'cy', pos.y);
    circle.setAttributeNS(null, 'r', r);
    circle.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + ';  opacity:1; stroke-width:' + strokeWidth + ';');        
    layer.appendChild(circle);
}

function createCircleSimple(pos, id, layer, colour){
    colour = (colour==undefined)? "#561234":colour;
    createCircle(id, pos, 1, colour, "none", 0, layer, null);
}

function createText(id, pos, fill, layer){
    var text = document.createElementNS(svgns, 'text');
    if(id!==null) text.setAttributeNS(null, 'id', id);
    text.setAttributeNS(null, 'class', "svg-text");
    text.setAttributeNS(null, 'x', pos.x);
    text.setAttributeNS(null, 'y', pos.y);
    text.setAttributeNS(null, 'style', 'fill:' + fill + ';');        
    layer.appendChild(text);        
}

function createAnimation(id, attributeName, values, dur, repeatCount){
    const animationId = "ani_" + randomIntFromInterval(1, 1000);
    const animation = document.createElementNS(svgns, 'animate');
    animation.setAttribute("id", animationId); 
    animation.setAttribute("attributeType", "XML"); 
    animation.setAttribute("attributeName", attributeName); //"stroke-width"
    animation.setAttribute("values", values); //"6;1;6;1"
    animation.setAttribute("dur", dur + "s"); 
    animation.setAttribute("repeatCount", repeatCount); 
    const el = document.getElementById(id);
    if(el==null){ //if element does not exist
        return false;
    }    
    el.appendChild(animation);        
    const elAnimation = document.getElementById(animationId); 
    elAnimation.beginElement();
    setTimeout(function(){elAnimation.remove()}, (dur*repeatCount) * 1000);
}

function createOrUpdateText(id, pos, fill, layer, value){
    var el = document.getElementById(id);
    if(el==null){
        createText(id, pos, fill, layer);
        el = document.getElementById(id); //reset is needed?
    }
    el.innerHTML = value;    
}

function createPath(pathInfo, fill, stroke, strokeWidth, id, layer, closePath){
    if(typeof pathInfo==="string"){
        var d = pathInfo; //is a string            
    }else{
        if(pathInfo.length!=0){    
            var d = createPathString(pathInfo, closePath); //is a point array
        }else{
            return false;
        }
    }
    var path = document.createElementNS(svgns, 'path');
    path.setAttributeNS(null, 'id', id);
    path.setAttributeNS(null, 'd', d);
    if(fill!==null & stroke!==null){
        path.setAttributeNS(null, 'style', 'fill:' + fill + '; stroke:' + stroke + '; stroke-width:' + strokeWidth + ';');
    }
    layer.appendChild(path);
}

function createPathString(posList, closePath){
    var d = "M" + + posList[0].x + " " + posList[0].y;
    for(var i=1; i<posList.length; i++) {
        d += " L" + posList[i].x + " " + posList[i].y;
    }
    if(closePath) d += " z";
    return d;
}

function createOrUpdatePath(pathInfo, fill, stroke, strokeWidth, id, layer, closePath){
    const el = document.getElementById(id);
    if(pathInfo.length==0) return false;
    const d = (typeof pathInfo==="string")? pathInfo:createPathString(pathInfo, closePath);
    if(el!=null){
        el.setAttribute("d", d);
    }else{
        createPath(pathInfo, fill, stroke, strokeWidth, id, layer, closePath);
    } 
}

function pointListFromSvgString(svgTxt){
    var layer = 1;
    var pointList = [];
    var svgLetters =["M","L","H","V","C","Q","A"]
    var indices = [];
    for(var i=0; i<svgTxt.length; i++){
        for(var j=0; j<svgLetters.length; j++){  
            if(svgTxt[i]===svgLetters[j]){
                indices.push(i); //matches
                break;    
            }
        }        
    }
    indices.push(svgTxt.length); //last character   
    for(var i=0; i<indices.length-1;i++){
        const pathStart = indices[i];
        const pathEnd = indices[i+1];
        const pathType = svgTxt.charAt(pathStart);
        const pathValues = svgTxt.substring(pathStart,  pathEnd).replace(pathType, "").trim();
        const pathList = pathValues.split(" ");
        //console.log(pathType, pathValues, pathList);
        
        if(pathType==="M" || pathType==="L"){
            pointList.push(new SvgPoint(layer, pathType, pathList[0], pathList[1])); 
            //console.log(layer, pathType, pathList[0], pathList[1]);    
        }else if(pathType==="H"){
            pointList.push(new SvgPoint(layer, pathType, pathList[0]));
            //console.log(layer, pathType, pathList[0]);
        }else if(pathType==="V"){
            pointList.push(new SvgPoint(layer, pathType, pathList[1]));
            //console.log(layer, pathType, pathList[0]);  
        }else if(pathType==="C"){
            pointList.push(new SvgPoint(layer, pathType, pathList[4], pathList[5], pathList[0], pathList[1], pathList[2], pathList[3]));
            //console.log(layer, pathType, pathList[4], pathList[5], pathList[0], pathList[1], pathList[2], pathList[3]);
        }else if(pathType==="Q"){
            pointList.push(new SvgPoint(layer, pathType, pathList[2], pathList[3], pathList[0], pathList[1]));
            //console.log(layer, pathType, pathList[2], pathList[3], pathList[0], pathList[1]);
        }else if(pathType==="A"){
            pointList.push(new SvgPoint(layer, pathType, pathList[5], pathList[6], null, null, null, null, pathList[0], pathList[1],pathList[2],pathList[3],pathList[4]));
            //console.log(layer, pathType, pathList[5], pathList[6], null, null, null, null, pathList[0], pathList[1],pathList[2],pathList[3],pathList[4]);
        }
    }
    return pointList;
}

function polyShapePath(pos, radius, sides, rotation){
    var pathList = [];
    for(var i=0; i<sides; i++){
        pathList.push(rotateAroundPoint(pos, ((360/sides) * i) + rotation, radius));
    }
    return pathList;
}

function createOrUpdateCircle(id, index, hexIndex, pos, className, radius, stroke, strokeWidth, layer){
    const colour = (hexIndex==-1)? "none":getHexColour(hexIndex); //offset to make stand out
    const el = document.getElementById(id);
    if(el!=null){
        el.setAttribute("cx", pos.x);
        el.setAttribute("cy", pos.y);
    }else{
        createCircle(id, pos, radius, colour, stroke, strokeWidth, layer, "none");
    } 
}
////////////////////////////////////////SVG Functions End//////////////////////////////////////////
////////////////////////////////////////General Functions Start////////////////////////////////////
function isEven(n) {
   return n % 2 == 0;
}

function randomIntFromInterval(min, max){ // min and max included 
  return Math.floor(Math.random() * (max - min + 1) + min);
}

function niceNum(num, decimalPlaces){
    const numType = typeof num
    if(numType == "string") num = Number(num);
    if(numType == "undefined" || num == null) num = 0;
    decimalPlaces = (decimalPlaces!==undefined)? decimalPlaces:3;
    num = (Number.isInteger(num))? Number(num):Number(num.toFixed(decimalPlaces));
    return parseFloat(num); //removes trailing zeros
}

function getIndex(num, total){
    let index = num % total
    if(index<0){
       index = total + num;
    }
    return index;
}

function getHexColour(index){
    return hexColourList[getIndex(index, hexColourList.length)];
}

function getHexOpacity(val){
    if(val<0) val=0;
    if(val>100) val=100;
    val = val/10;
    return hexOpacityList[val];
}

function clearLayers(includePoints, includeCropped){
    if(includePoints){
        sessionData.rotatedPoints = [];
        sessionData.rotatedShapes = [];
        layerPoints.innerHTML = "";
        
    }
    if(includeCropped) layerCrop.innerHTML = "";      
    layerRotatedPoints.innerHTML = ""; 
}

function saveAndUpdate(){
    createPointButtons();
    createPatternButtons();
    createShapeButtons();
    saveLocalStorage();
    updatePoints();   
}  

function changeShapeOpacity(num){
    sessionData.shapeOpacity = num;
    layerShapes.setAttribute("opacity", sessionData.shapeOpacity/100);
    shapeOpacityText1.innerHTML = sessionData.shapeOpacity + "%";
}

function changeUnselectedShapeOpacity(num){
    sessionData.unselectedShapesOpacity = Number(num);
    shapeOpacityText2.innerHTML = sessionData.unselectedShapesOpacity + "%";
    redrawShapes(); 
} 

function percentageToHexAlpha(percentage) {
    if (typeof percentage !== 'number' || percentage < 0 || percentage > 100) {
        throw new Error('Input must be a number between 0 and 100');
    }
    // Convert percentage to value between 0 and 255
    const value = Math.round((percentage / 100) * 255);
    // Convert value to 2-digit hexadecimal
    let hex = value.toString(16).toUpperCase();
    // Ensure it is two digits
    if (hex.length === 1) {
        hex = '0' + hex;
    }
    return hex;
}

function radiusOfRegularPolygon(sideLength, numberOfSides){
    //return sideLength/2sin(180/numberOfSides);
    return sideLength/(2*Math.sin(Math.PI/numberOfSides));
}

function sideOfRegularPolygon(polygonRadius, numberOfSides){
    let angle = (360/numberOfSides) * 0.5;
    let opposite = Math.sin(Math.PI/180 * angle) * polygonRadius;    
    return opposite * 2
}

//console.log(radiusOfRegularPolygon(58.779, 5));
//console.log(sideOfRegularPolygon(6.5, 5));
////////////////////////////////////////General Functions End//////////////////////////////////////////
////////////////////////////////////////Display Start//////////////////////////////////////////////////
function resetZoomAndPanBtn(){
    var design = getCurrentDesign(); 
    design.zoom = 100;
    design.panLeft = 0;
    design.panUp = 0;
    changeZoom(0, 0, 0);
}

function changeZoom(zoom, panLeft, panUp){
    //appData.zoom += zoom;
    var design = getCurrentDesign(); 
    design.zoom += zoom;
    design.panLeft += Math.floor(panLeft);
    design.panUp += Math.floor(panUp);
    //zoomText.innerHTML = appData.zoom;
    zoomText.innerHTML = design.zoom;
    panLeftText.innerHTML = design.panLeft;
    panUpText.innerHTML = design.panUp;
    
    //const originalWidth = designSvg.getAttribute("height");  
    const newSize = Math.floor((100/design.zoom)*sessionData.svgHeight);   
    designSvg.setAttribute("viewBox", design.panLeft + " " + design.panUp + " " + newSize + " " + newSize);
    updateCrop();
    saveLocalStorage();
}

function changeDisplay(btn, layerName){
    let layer = document.getElementById(layerName);
    let classNameLayer = (layer.getAttribute("class").includes("hideLayer"))? "showLayer":"hideLayer";
    let classNameBtn = (layer.getAttribute("class").includes("hideLayer"))? "green-btn green-btn-on":"green-btn green-btn-off";    
    layer.setAttribute("class", classNameLayer);
    btn.setAttribute("class",classNameBtn);    
    if(layerName=="layerPoints") document.getElementById("layerRotatedPoints").setAttribute("class", classNameLayer);
}
////////////////////////////////////////Display End////////////////////////////////////////////////////
////////////////////////////////////////Mode Start/////////////////////////////////////////////////////
function updateShapeBtns(){
    const shapeRenderList = ["make","rotate","repeat","radial"];    
    shapeRenderList.forEach(function(renderType){
        const elList = document.querySelectorAll("." + renderType + "-btn")
        if(getCurrentDesign().shapeRenderType==renderType){
            elList.forEach(function(el){
                el.classList.add("group-btn-on");
            });                
        }else{
            elList.forEach(function(el){
                el.classList.remove("group-btn-on");
            }); 
        }    
    });
}

function changeSnap(str){
    const snapModeList = ["point","shape","tool","grid"];
    if(str!=""){
        const index = sessionData.snapMode.indexOf(str);
        if(index==-1){
            sessionData.snapMode.push(str); 
        }else{
            sessionData.snapMode.splice(index, 1);
        }
    }
    snapModeList.forEach(function(snapMode){
        const elList = document.querySelectorAll("." + snapMode + "-btn");
        if(sessionData.snapMode.includes(snapMode)){
            elList.forEach(function(el){
                el.classList.add("group-btn-on");
            });            
        }else{
            elList.forEach(function(el){
                el.classList.remove("group-btn-on");
            }); 
        }      
    });
}

function redrawShapes(){
    if(getCurrentDesign().shapeRenderType=="make"){
        makeShapeBtn();
    }else if(getCurrentDesign().shapeRenderType=="rotate"){  
        rotateShapesBtn();
    }else if(getCurrentDesign().shapeRenderType=="repeat"){ 
        repeatShapesBtn();
    }else if(getCurrentDesign().shapeRenderType=="radial"){ 
        radialRepeatShapesBtn();
    }  
}

function changeMode(mode){
    sessionData.mode = mode;
    if(mode=="points"){ 
        changePointBtn(sessionData.pointIndex);
        layerShapes.setAttribute("opacity", sessionData.shapeOpacity/100);
        redrawShapes();  
    }else if(mode=="shapes"){
        layerShapes.setAttribute("opacity", 1);
        changeShape(sessionData.shapeIndex);
    }else if(mode=="patterns"){
        layerPattern.setAttribute("opacity", 1);
        redrawShapes();        
    }
    
    if(mode=="patterns"){
        layerPattern.setAttribute("opacity", 1);
    }else{
        layerPattern.setAttribute("opacity", 0);
    }

    if(mode=="crop"){
        layerCrop.setAttribute("opacity", 1);
    }else{
        layerCrop.setAttribute("opacity", 0);
    }

    

    
    
    
    //will remove if not in crop mode;
    updateCrop();
}

function updateMode(mode){
    sessionData.mode = mode;
    updateTopInfoPanel(mode);
}

function selectMode(containerId, mode){
    //Show Hide ControlPanel
    const containers = ["pointContainer","shapeContainer","patternContainer","toolContainer","gridContainer","designContainer","exportContainer","cropContainer","backgroundContainer"];
    containers.forEach(function(containerName){
        const containerStyle = (containerName==containerId)? "show":"hide";
        const chevronStyle = (containerName==containerId)? "chevron up":"chevron down";
        document.getElementById(containerName.replace("Container","Chevron")).setAttribute("class",chevronStyle)
        document.getElementById(containerName).setAttribute("class", "container " + containerStyle);
    });
    //Update    
    changeMode(mode);
    updateMode(mode)
    changeSnap("");
    updateShapeBtns();    
}
////////////////////////////////////////Mode End///////////////////////////////////////////////////////
////////////////////////////////////////Change Properties Start////////////////////////////////////////
function changeSwitch(btn, objName){
    obj = appData[objName];
    appData[objName] = !obj;
    const classValue = (appData[objName])? "green-btn green-btn-on":"green-btn green-btn-off";    
    btn.setAttribute("class",classValue);
}

function changeRotation(val, standard){ //points
    var point = getCurrentPoint();
    val = (standard)? point.rotation+val:Number(val);
    point.rotation = val;
    rotationText.innerHTML = val;
    saveAndUpdate();
}

function changeColourValueBasic(id, val){ //shapes
    el = document.getElementById(id);
    el.innerHTML = val;
    el.setAttribute("style", `background-color: ${val};`);   
}

function changeRepeatX(val, standard){ //patterns
    getCurrentDesign().xRepeat += val;
    repeatXText.innerHTML = getCurrentDesign().xRepeat;
    redrawShapes();    
    saveLocalStorage();
}

function changeRepeatY(val, standard){ //patterns
    getCurrentDesign().yRepeat += val;
    repeatYText.innerHTML = getCurrentDesign().yRepeat;
    redrawShapes();     
    saveLocalStorage();     
}

function changeAngle(val, standard){ //points
    const point = getCurrentPoint();
    const cent = getPoint(point.connect);
    const angle = (standard)? point.angle+val:Number(val);
    const p = rotateAroundPoint(cent, angle, point.length)
    angleText.innerHTML = angle;
    movePoint(p.x, p.y, true);
    redrawShapes();
    saveAndUpdate();
}

function changeLength(val, standard){ //points
    const point = getCurrentPoint();
    const cent = getPoint(point.connect);
    const length = (standard)? point.length+val:Number(val);
    const p = rotateAroundPoint(cent, point.angle, length);
    movePoint(p.x, p.y, true);
    redrawShapes();
    saveAndUpdate();
}

function changeX(val, standard){ //points
    const point = getCurrentPoint();
    const x = (standard)? point.x+val:Number(val);
    redrawShapes();
    movePoint(x, point.y, true);
}

function changeY(val, standard){ //points
    const point = getCurrentPoint();
    const y = (standard)? point.y+val:Number(val);
    redrawShapes();
    movePoint(point.x, y, true);
}

function changeColourValue(id, val){ //backgroundColourPicker
    if(id=='update') return false;
    colourInput = document.getElementById(id);
    colourBtn = document.getElementById(id + 'Btn');
    colourInput.value = val;
    colourBtn.innerHTML = val;
    colourBtn.setAttribute("style", `background-color: ${val};`);   
}

function changePropValue(name, propName, val, textId, colourId, isIncrimental){  
    //console.log(name, propName, val, textId, colourId, isIncrimental);
    if(name=="shape"){
        var obj = getCurrentShape();        
    }else if(name=="tool"){
        var obj = getCurrentTool();
    }else if(name=="design"){
        var obj = getCurrentDesign();
    }else if(name=="appData"){
        var obj = appData;
    }else if(name=="sessionData"){
        var obj = sessionData;
    }
    
    if(obj==undefined){
        return false;
    }    
    
    //const prop = obj[prop];
    if(val!='update'){
        val = (isIncrimental)? obj[propName]+val:val;
        obj[propName] = val;
    }    
    if(textId!=null & textId!="colour-input"){
        document.getElementById(textId).innerHTML = obj[propName];
    }   
        
    if(colourId!=null){
        changeColourValue(colourId, obj[propName])
    }

    if(val!='update'){
         saveAndUpdate();
    }    

    if(name=="design"){
        redrawShapes();
    }

}

////////////////////////////////////////Change Properties End//////////////////////////////////////////////////
////////////////////////////////////////Design Start//////////////////////////////////////////////////
function getCurrentDesign(){
    return  getDesign(appData.designIndex);
}

function getDesign(id){
    return appData.designs[appData.designIndex];
}

function changeDesign(index){
    clearLayers(true, true);
    resetIndexes();
    appData.designIndex = index;
    let design = getCurrentDesign();
    sessionData.toolNameList = design.tools.map(tool => (tool.name));
    sessionData.snapPoints = [];
    designNameUpdateText.value = design.title;
    changeZoom(0, 0, 0);
    changeBackgroundOpacity(design.bgOpacity);
    changeBackgroundRotation(design.bgRotate * 10);
    changeBackgroundZoom(design.bgZoom);
    changeRepeatY(0);
    changeRepeatX(0);
    if(sessionData.toolNameList.includes('straightDivision')){
        changeToolValue('straightDivision', 'division', 'update', 'divisionText', false) 
    }
    if(sessionData.toolNameList.includes('isometricGrid')){
        changeToolValue('isometricGrid', 'triangleHeight', 'update', 'triangleHeightText', false);
        changeToolValue('isometricGrid', 'xRepeat', 'update', 'xRepeatIsoText', false);
        changeToolValue('isometricGrid', 'yRepeat', 'update', 'yRepeatIsoText', false);
        //changeToolValue('isometricGrid', 'rotation', 'update', 'gridRotationText', false); 
        changeToolValue('isometricGrid', 'xStart', 'update', 'xStartIsoText', false);
        changeToolValue('isometricGrid', 'yStart', 'update', 'yStartIsoText', false);
        changeToolValue('isometricGrid', 'colour', 'update', 'gridColourPicker', false);
    }
    if(sessionData.toolNameList.includes('rectangularGrid')){
        changeToolValue('rectangularGrid', 'xRepeat', 'update', 'rectangularxRepeatText', false);
        changeToolValue('rectangularGrid', 'yRepeat', 'update', 'rectangularyRepeatText', false);
        changeToolValue('rectangularGrid', 'colour', 'update', 'rectGridColourPicker', false); 
    } 
    if(sessionData.toolNameList.includes('polystar')){
    changeToolValue('polystar', 'sides', 'update', 'changePolyStarQtyTxt', false) 
    }
    //changePropValue('shape', 'fill', 'update', 'colour-input', 'shapeFillPicker', false);
    //changePropValue('shape', 'stroke', 'update', 'colour-input', 'shapeStrokePicker', false);
    changePropValue("appData", "guideColour", 'update', 'colour-input', 'guideColourInput', false);
    changePropValue("design", "outlineColour", 'update', 'colour-input', 'cropOutlineColour', false);    
    changePropValue('design', 'articulateCurve', 'update', 'articulateCurveTxt', null, true);
    
    
    gridColourPicker.value = getToolByName("isometricGrid").colour;      
    changeOutlineWidth(0, true)
    loadBackgroundImage();
    changeBackgroundColor(false);    
    updateCrop();
    saveAndUpdate();
}

function resetIndexes(){
    sessionData.shapeIndex = 0; //required as may be lower than prev design
    sessionData.pointIndex = 0; //required
    sessionData.patternPointIndex = 0;
}
/*
function changeDesignProperty(propName, val, isIncrimental){
    const design = getCurrentDesign();    
    val = (isIncrimental)? point[propName]+val:val;
    design[propName] = val;         
    changePointBtn(sessionData.pointIndex);
    saveLocalStorage();
}
*/
function updateDesignSelector(){
    let selectHtml = "";
    let title = getCurrentDesign().title;
    appData.designs.forEach(function(val, index){
        var selected = (val.title == title)? " selected":"";
        selectHtml += '<option value="' + index + '"' + selected + '>' + val.title + '</option>';
    });
    designSelect.innerHTML = selectHtml;
    //designNameUpdateText.value = title;
}

function addNewDesignBtn(designName){    
    appData.designs.push(new Design(designName, "images/" + fileData.value));
    appData.designIndex = appData.designs.length - 1;
    appData.designs[appData.designIndex].points.push(new Point(300, 300));
    resetOnDesignChange(appData.designIndex);
}

function updateDesignTitleBtn(){
    getCurrentDesign().title = designNameUpdateText.value;
    updateDesignSelector();
    saveAndUpdate();
}

function updateDesignBackgroundImageBtn(){
    getCurrentDesign().image = "images/" + fileData.value;
    saveAndUpdate();
    loadBackgroundImage();
}


function duplicateDesignBtn(){
    const clone = cloneObject(getCurrentDesign());
    clone.title = clone.title + "_copy";
    appData.designs.push(clone);
    resetOnDesignChange(appData.designs.length - 1);
}

function deleteDesignBtn(){
    console.log(getCurrentDesign(), sessionData.designIndex);
    appData.designs.splice(appData.designIndex, 1);
    resetOnDesignChange(appData.designs.length - 1);   
}

function resetOnDesignChange(index){
    saveLocalStorage();
    changeDesign(index);
    updateDesignSelector();
}
////////////////////////////////////////Design End//////////////////////////////////////////////////
////////////////////////////////////////SVG Interactivity Start ////////////////////////////////////
function getMousePos(evt, svgA, adjust) {
    try{
        //if(isTouchDevice){
        //  var pos = {x: evt.touches[0].clientX, y: evt.touches[0].clientY};
        //}else{
        var pos = {x: evt.clientX, y: evt.clientY};
        //}
        var rect = svgA.getBoundingClientRect();
        if(adjust){
        pos.x -= rect.left;
        pos.y -= rect.top;
        }
    } catch(err) {
        return {x:0, y:0}; //!!!
    }
    return pos;
}

function mouseCoordsTransformed(mouse) {
    var pt = designSvg.createSVGPoint();  // Created once for document
    pt.x = mouse.x;
    pt.y = mouse.y;
    var cursorpt =  pt.matrixTransform(designSvg.getScreenCTM().inverse());
    return cursorpt;
}

function findClosestControlPoint(mousePosition){
    var testDistance = 20;
    var closestPoint = -1;
    var pointType = "";
    var obj = {x:0, y:0, id:"", isLocked:false, point:{}};
    var info = {index:-1, type:"", obj:obj}
    //point points list
    getCurrentDesign().points.forEach(function(point, index){
        if(point!=null){
            //console.log(point)
            //let point = Object.assign({}, point);
            var length = calculateDistance(point,mousePosition,true);
            if(length<testDistance){
                testDistance = length;
                info = {index:index, type:"point", obj:{x:point.x, y:point.y, id:letters[index] + "0", isLocked:point.isLocked}, point:point}    
            } 
        }
    });
    //pattern point points list   
    getCurrentDesign().patternPoints.forEach(function(point, index){
        if(point!=null){
            var length = calculateDistance(point,mousePosition,true);
            if(length<testDistance){                
                testDistance = length;
                info = {index:index, type:"patternPoint", obj:{x:point.x, y:point.y, id:"p" + (index+1), isLocked:false}, point:point}               
            } 
        }   
    });  
    //crop points list
    getCurrentDesign().cropPoints.forEach(function(point, index){
        var length = calculateDistance(point,mousePosition,true);
        if(length<testDistance){
            testDistance = length; 
            info = {index:index, type:"cropPoint", obj:{x:point.x, y:point.y, id:"crop" + (index+1), isLocked:false}, point:point}       
        } 
    });   
    //rotated points list
    sessionData.rotatedPoints.forEach(function(point, index){
        var length = calculateDistance(point,mousePosition,true);
        if(length<testDistance){
            testDistance = length; 
            info = {index:index, type:"rotated", obj:point}             
        } 
    }); 
    sessionData.pointType = info.type;
    return info;
}

function getClosestPointIndex(pointList, mousePosition){
    var testDistance = 20;
    var obj = {x:0, y:0, index:-1}; 
    pointList.forEach(function(val, index){
        if(val!=null){
            var length = calculateDistance(val,mousePosition,true);
            if(length<testDistance){
                pointType = "point";
                closestPoint = index; 
                testDistance = length;
                obj = {x:mousePosition.x, y:mousePosition.y, index:closestPoint};    
            } 
        }
    });
    return obj;
}

function findSnap(snapList, mousePosition, id){
    for(i=0; i<snapList.length; i++){
        var snapPoint = snapList[i];
        if(calculateDistance(mousePosition, snapPoint, true)<10){
            if(snapPoint.id!=id){ //dont return self
                return snapPoint;
            }
        }
    }
    return mousePosition;
}

function downHandler(evt){
    const mouse = getMousePos(evt, designSvg, false);
    const mousePosition = mouseCoordsTransformed(mouse);
    const closestPoint = findClosestControlPoint(mousePosition);    
    const design = getCurrentDesign();
    const tool = getCurrentTool();
    const mode = sessionData.mode;
    const pointType = sessionData.pointType;
    
    /*
    //check pairs
    if(pointType==="point"){
        const pairedPoint = closestPoint.point.pair;
        if(pairedPoint==undefined ){
            sessionData.pairedPoint = -1;        
        }else{
            sessionData.pairedPoint = pairedPoint;
        } 
        console.log(sessionData.pairedPoint)    
    } 
    
    */
    //pointInfo.innerHTML = closestPoint.obj.id;
    const isLocked = closestPoint.isLocked;
    
    
    if(mode=="points" & closestPoint.type=="point"){
        sessionData.pointIndex = closestPoint.index; //set index          
        saveAndUpdate();
        redrawShapes();
        sessionData.drag = true; 
    }else if(mode=="shapes" & (pointType=="point" || pointType=="rotated")){
        const shape = getCurrentShape();
        let lastPoint = shape.data[shape.data.length-1];
        if(lastPoint!=closestPoint.obj.id & shape.isLocked==false){            
            shape.data.push(closestPoint.obj.id);
            changeShape(sessionData.shapeIndex);
        }
    }else if(mode=="patterns"){    
        if(sessionData.pointType=="patternPoint"){
            sessionData.patternPointIndex = closestPoint.index;
            changePatternPointBtn(closestPoint.index);
            sessionData.drag = true;
        }else{
            let repeatedShapePoint = findSnap(sessionData.snapPoints, mousePosition, "x");
            if(repeatedShapePoint.id!=undefined & sessionData.selectedSnapsIsSelecting){
                let selectedSnaps = sessionData.selectedSnaps;
                selectedSnaps.push(repeatedShapePoint);
                if(selectedSnaps.length==2){
                    const currentPatternPoint = design.patternPoints[sessionData.patternPointIndex];
                    const x = selectedSnaps[1].x - selectedSnaps[0].x;
                    const y = selectedSnaps[1].y - selectedSnaps[0].y;
                    movePoint(x, y, false);
                    sessionData.selectedSnapsIsSelecting = false;
                    selectedSnaps = [];
                }                
            }
            /*
            if(repeatedShapePoint.id!=undefined){        
                if(repeatedShapePoint.p.x==0, repeatedShapePoint.p.y==0){
                    sessionData.patternPointIndex = 0; 
                }else if(repeatedShapePoint.p.x==0, repeatedShapePoint.p.y==1){
                    sessionData.patternPointIndex = 1; 
                }
                patternSnapText.value = repeatedShapePoint.id;            
                let patternPoint = design.patternPoints[sessionData.patternPointIndex];
                sessionData.patternSnapOffset = {x:repeatedShapePoint.x - patternPoint.x, y:repeatedShapePoint.y - patternPoint.y}
                //console.log(sessionData.patternSnapOffset)
                //createCircle("patternSnapOffset", sessionData.patternSnapOffset, 2, "#561234cc", "none", 0, layerPoints, "none");
            } 
            */
        } 
    }else if(mode=="tools"){ 
        if(tool.name=="polystar" || tool.name=="centroid"){
            let tempArray = [...tool.points];
            tempArray.push(getPolygonCentroid(tool.points));        
            var point = getClosestPointIndex(tempArray, mousePosition);         
        }else{
            var point = getClosestPointIndex(tool.points, mousePosition);            
        }
        sessionData.toolPointIndex = point.index;
        sessionData.drag = true; 
    }else if(mode=="crop" & pointType=="cropPoint"){
        sessionData.cropPointIndex = closestPoint.index;
        sessionData.drag = true;        
    }else if(mode=="add point"){
        console.log("adding point");
        design.points.push(new Point(mousePosition.x, mousePosition.y));
        sessionData.pointIndex = design.points.length - 1; //select current
        saveAndUpdate();
        createPointButtons();
        changeMode("points");    
    } 
}

function moveHandler(evt){
    //evt.preventDefault(); //should stop scrolling
    const mouse = getMousePos(evt, designSvg, false);
    let mousePosition = mouseCoordsTransformed(mouse); 
    const mode = sessionData.mode;
    const pointType = sessionData.pointType;
    
    //update hud
    if(sessionData.mode=="points" || sessionData.mode=="shapes"){
        if(mouse.x<1060){
            
            hudLineVertical.setAttribute('d', `M${mousePosition.x} 0  L${mousePosition.x} 2000`);
            hudLineHorizontal.setAttribute('d', `M-300 ${mousePosition.y} L2000 ${mousePosition.y}`);            
        }
    }
    //snapping
    if(sessionData.snapMode.includes("point")){
        mousePosition = findSnap(sessionData.snapPoints, mousePosition, "x");
        mousePosition = findSnap(sessionData.rotatedPoints.concat(getCurrentDesign().points), mousePosition, "x");         
    }
    if(sessionData.snapMode.includes("shape")){
        for(let i=0; i<sessionData.rotatedShapes.length; i++){
            const mp = findSnap(sessionData.rotatedShapes[i], mousePosition, "x");
            if(mp!=mousePosition){
                mousePosition = mp;
                break;
            }    
        }
    }
    if(sessionData.snapMode.includes("tool")){
        mousePosition = findSnap(sessionData.toolSnapPoints, mousePosition, "x");    
    }
    if(sessionData.snapMode.includes("grid")){
        mousePosition = findSnap(sessionData.gridSnapPoints, mousePosition, "x"); //first prioritory
    }
    //update tooltip
    var xPosition = ((mouse.x + 30)<1060)? (mouse.x + 30):1060
    tooltip.setAttribute("style",   "position: absolute; left: " + xPosition + "px; top: " + ((mouse.y - 30)+window.pageYOffset) + "px;")
    //update if drag
    if(sessionData.drag){
        if(mode=="points" & pointType=="point"){ //only points        
            movePoint(mousePosition.x, mousePosition.y, true);
            redrawShapes(); 
        }else if(mode=="shapes"){         
            //no dragging of points here
        }else if(mode=="patterns" & pointType=="patternPoint"){
            let firstRepeatedShape = sessionData.snapPoints.filter(element => element.p.x == 0 & element.p.y == 0);
            //limit y movement of first
            if(sessionData.patternPointIndex==0){
                 mousePosition = {x:mousePosition.x, y:getCurrentDesign().points[0].y};            
            }            
            //console.log(sessionData.patternSnapOffset);            
            let point = {x:mousePosition.x+sessionData.patternSnapOffset.x, y:mousePosition.y+sessionData.patternSnapOffset.y}
            //createCircle("patternSnapOffset", point, 2, "#561234cc", "none", 0, layerPoints, "none");
            
            let snapPoint = findSnap(sessionData.snapPoints, point, "x"); //
            
            if(snapPoint.x!=point.x & snapPoint.y!=point.y){ //as it returns same if not found
                    console.log(snapPoint);
                    mousePosition.x = snapPoint.x-sessionData.patternSnapOffset.x
                    if(sessionData.patternPointIndex!=0) mousePosition.y = snapPoint.y-sessionData.patternSnapOffset.y
            }
            
            movePoint(mousePosition.x, mousePosition.y, true);
        }else if(mode=="crop" & pointType=="cropPoint"){
            movePoint(mousePosition.x, mousePosition.y, true);
        }else if(mode=="tools"){
            const tool = getCurrentTool();
            if(sessionData.toolPointIndex>tool.points.length-1){ //is polystar centroid
                tool.centroid = mousePosition;
                makeTool(tool.name);
            }else if(sessionData.toolPointIndex!=-1){
                tool.points[sessionData.toolPointIndex] = mousePosition;
                makeTool(tool.name);
            }
        }    
    }else{
        //update tooltip    
        var closestPoint = findClosestControlPoint(mousePosition);
        tooltip.innerHTML = closestPoint.obj.id;        
    }   
}

function upHandler(evt){
    sessionData.drag = false;    
    saveLocalStorage();
} 

function leaveHandler(evt){
    hudLineHorizontal.setAttribute('d', 'M0 0 L0 0');
    hudLineVertical.setAttribute('d', 'M0 0 L0 0');
}

function checkKey(e) {
    e = e || window.event;
    const controlKeyDown = e.ctrlKey;
    var moveAmount = 0.5;
    if (e.keyCode == '38') {
        //appData.panLeft
        e.preventDefault();
        if(controlKeyDown){
            changeZoom(0,0,10);
        }else{
            movePoint(0, -moveAmount, false); //up arrow 
        }        
    }else if (e.keyCode == '40'){
        e.preventDefault();
        if(controlKeyDown){
            changeZoom(0,0,-10);
        }else{
            movePoint(0,moveAmount, false); //down arrow
        }        
    }else if (e.keyCode == '37'){
        e.preventDefault();        
        if(controlKeyDown){
            changeZoom(0,10,0)
        }else{
            movePoint(-moveAmount,0, false); //left arrow 
        }
    }else if (e.keyCode == '39'){
        e.preventDefault();
        if(controlKeyDown){
            changeZoom(0,-10,0)
        }else{
            movePoint(moveAmount,0, false); //right arrow
        }
        
    }
}

//listners
designSvg.addEventListener("mousedown", downHandler, false);
designSvg.addEventListener("mousemove", moveHandler, false);
designSvg.addEventListener("mouseup", upHandler, false);
designSvg.addEventListener("mouseleave", leaveHandler, false);
document.onkeydown = checkKey;
////////////////////////////////////////SVG Interactivity End//////////////////////////////////////////
////////////////////////////////////////Interface Start////////////////////////////////////////////////
function updateTopInfoPanel(str){
    topInfoPanel.innerHTML = str;
}
////////////////////////////////////////Interface End////////////////////////////////////////////////
////////////////////////////////////////Tools Start//////////////////////////////////////////////////
function getCurrentTool(){
    return appData.designs[appData.designIndex].tools[sessionData.toolIndex]
}

function getToolByName(name){
    let toolIndex = getCurrentDesign().tools.findIndex(x => x.name === name);
    //console.log(toolIndex)
    if(toolIndex==-1){
        //get from tools array   
        let tool = tools.find(x => x.name === name);
        if(tool==undefined){ //tool not found
            return false;
        }
        getCurrentDesign().tools.push(cloneObject(tool)); //Add   
        toolIndex = getCurrentDesign().tools.length-1; //Get index 
        sessionData.toolIndex = toolIndex;
        centerToolBtn(false);    
    }
    sessionData.toolIndex = toolIndex;
    return getCurrentTool();
}

function showHideTools(){ 
    document.getElementById("layerTools").setAttribute("style", "opacity:" + opacity + ";");
}

function angleBetweenTwoLines(A1, A2, B1, B2){
    var dAx = A2.x - A1.x;
    var dAy = A2.y - A1.y;
    var dBx = B2.x - B1.x;
    var dBy = B2.y - B1.y;
    var angle = Math.atan2(dAx * dBy - dAy * dBx, dAx * dBx + dAy * dBy);
    //if(angle < 0) {angle = angle * -1;}
    //var degree_angle = angle * (180 / Math.PI);
    return angle * (180 / Math.PI);
}

function getExtensionOfIntersectLines(startPoint, endPoint, extensionLength){
    const length = calculateDistance(startPoint, endPoint, true);
    const percentage = (extensionLength/length) + 1;
    return findPointOnLine(startPoint, endPoint, percentage);    
}

function checkIntersect(tool, guideHandleSize){
    const pointList = tool.points;
    var intersectList = [];
    if(tool.extension==undefined){
        tool.extension = 100;
    }
    for(var i=0; i<pointList.length; i+=2){
        const startPoint = pointList[i];
        const endPoint = pointList[i+1];
        const extension1 = getExtensionOfIntersectLines(startPoint, endPoint, tool.extension);
        createPath([startPoint, endPoint], "none", appData.guideColour, 1, "toolName", layerTools, false);
        createPath([endPoint,extension1], "none", "#86d411", 0.5, "toolName", layerTools, false);
        createCircle("handle1", startPoint, guideHandleSize, "#561234cc", "none", 0, layerTools, "none");
        createCircle("handle2", endPoint, guideHandleSize, "#561234cc", "none", 0, layerTools, "none");        
        for(var j=0; j<pointList.length; j+=2){    
            if(i!=j){ //ignore self
                const startPoint2 = pointList[j];
                const endPoint2 = pointList[j+1]; 
                const extension2 = getExtensionOfIntersectLines(startPoint2, endPoint2, tool.extension);    
                const intersect = lineIntersect(startPoint, extension1, startPoint2, extension2, true);
                if(intersect!=false){
                    intersectList.push(intersect);
                    createCircle("x" + i, intersect, 1, "#561234cc", "none", 0, layerTools, "none");
                }    
            }   
        }   
    }
    return intersectList;
}

function makeTool(toolName){
    //const design = getCurrentDesign();
    layerTools.innerHTML = "";
    //const toolIndex = design.tools.findIndex(x => x.name === toolName);
    //sessionData.toolIndex = toolIndex;
    const tool = getToolByName(toolName);    //design.tools[toolIndex];
    const guideHandleSize = appData.guideHandleSize;
    if(toolName!="isometricGrid"){
        tool.nodes = [];  
    }
    if(toolName=="straightDivision"){
        //var tool = getCurrentDesign().tools.find(x => x.name === toolName);
        var length = calculateDistance(tool.points[0],tool.points[1],true);
        var strutLen = length/tool.division;
        createPath(tool.points, "none", appData.guideColour, 1, "toolName", layerTools, false);    
        for(var i=0; i<=tool.division; i++){
            var percent =strutLen*i/length;        
            var point = findPointOnLine(tool.points[0],tool.points[1],percent);
            tool.nodes.push(point);
            createCircle("x", point, guideHandleSize, "#561234cc", "none", 0, layerTools, "none");
        }        
        sessionData.toolSnapPoints = tool.nodes;
    }else if(toolName=="intersectLines"){
        sessionData.toolSnapPoints = checkIntersect(tool, guideHandleSize);
        extensionText.innerHTML = tool.extension;
        //sessionData.toolSnapPoints = tool.nodes;
    }else if(toolName=="centroid"){
        let centroidPoint = getPolygonCentroid(tool.points);
        if(sessionData.toolNodeIndex>tool.points.length-1){    
            let xAdjust = tool.centroid.x - centroidPoint.x; 
            let yAdjust = tool.centroid.y - centroidPoint.y;           
            tool.points = translateNodes(tool.points, xAdjust, yAdjust);
        }
        centroidPoint = getPolygonCentroid(tool.points);
        changeCentroidQtyTxt.innerHTML = tool.sides;
        //redrawShapes();        
        sessionData.toolSnapPoints = [centroidPoint];
        tool.nodes[0] = centroidPoint; //used in adding        
        const el = document.getElementById("temp");
        if(el!=null) el.remove();        
        createCircleSimple(centroidPoint, "temp", layerShapes);
        createPath(tool.points, "none", appData.guideColour, 1, "toolName", layerTools, true);

    
    }else if(toolName=="isometricGrid"){
        rectangularGridContainer.setAttribute("class", "hide");
        isometricGridContainer.setAttribute("class", "show");
        document.querySelector(".isometric-btn").classList.add("group-btn-on"); 
        document.querySelector(".rectangular-btn").classList.remove("group-btn-on");         
        createIsometricGrid(); 
    }else if(toolName=="internalAngle"){
        if(sessionData.toolNodeIndex==2){
            const lineAngle1 = angleBetweenTwoLines(tool.points[0], tool.points[2], tool.points[0], tool.points[1]);
            const lineAngle2 = angleBetweenTwoLines(tool.points[1], tool.points[0], tool.points[1], tool.points[2]); //correct
            let average = Math.abs((lineAngle1+lineAngle2)/2);
            if(average<=0) average=1;
            internalAngleText.value = average.toFixed(1);
        }  
        let internalAngle = Number(internalAngleText.value);
        const angle = lineAngle(tool.points[0], tool.points[1], true);
        //find intersect       
        const intersectPoint1 = rotateAroundPoint(tool.points[0], angle-internalAngle, 100);
        const intersectPoint2 = rotateAroundPoint(tool.points[1], (angle-internalAngle)-(180-(internalAngle*2)), 100);
        const intersectPoint = lineIntersect(tool.points[0], intersectPoint1, tool.points[1], intersectPoint2, false);       
        
        tool.points[2] = intersectPoint;
        createCircle("handle1", tool.points[2], guideHandleSize, "#561234cc", "none", 0, layerTools, "none");
        
        const rotatedPoint = rotatePoint(findPointOnLine(tool.points[0],tool.points[1], 0.5), intersectPoint, 180);        
        tool.nodes = [tool.points[0], intersectPoint, tool.points[1], rotatedPoint];
        createCircle("handle1", tool.points[0], guideHandleSize, "#561234cc", "none", 0, layerTools, "none");
        createCircle("handle2", tool.points[1], guideHandleSize, "#561234cc", "none", 0, layerTools, "none");        
        createPath([tool.points[0], tool.points[1]], "none", "#ccc", 1, "internalAngleInner", layerTools, true); 
        createPath(tool.nodes, "none", appData.guideColour, 1, "internalAngleOuter", layerTools, true);        
        sessionData.toolSnapPoints = tool.nodes;
        
        //centroidPoint = getPolygonCentroid(tool.points);
        //createCircle("x", centroidPoint, guideHandleSize, "#561234", "none", 0, layerTools, "none");
        
        
    }else if(toolName=="getAngle"){ 
        const lineAngle1 = lineAngle(tool.points[1], tool.points[0], false);
        const lineAngle2 = lineAngle(tool.points[1], tool.points[2], false);    
        const ang = angleBetweenTwoLines(tool.points[1], tool.points[0], tool.points[1], tool.points[2]);        
        const rotation1 = rotateAroundPoint(tool.points[1], lineAngle1, 60);
        const rotation2 = rotateAroundPoint(tool.points[1], lineAngle2, 60); 
        const rotation3 = rotateAroundPoint(tool.points[1], lineAngle1 + (ang*0.5), 60); 
        const rotation4 = rotatePoint(tool.points[1], rotation3, 180)
        const angleNum = Math.abs(parseFloat(ang.toFixed(1)));
        const angleNumAlt = 360-angleNum;
        const a = (ang<0)? 0:1;        
        getAngleText.value = angleNum;      
        createPath(tool.points, "none", appData.guideColour, 1, "toolName", layerTools, false);        
        createCircle("x", tool.points[0], guideHandleSize, "#123456", "none", 0, layerTools, "none");
        createCircle("x", tool.points[1], guideHandleSize, "#561234", "none", 0, layerTools, "none");
        createCircle("x", tool.points[2], guideHandleSize, "#561234cc", "none", 0, layerTools, "none");
        createPath(`M${rotation1.x} ${rotation1.y} A60 60 0 0 ${a} ${rotation2.x} ${rotation2.y} L${tool.points[1].x} ${tool.points[1].y}`, "#12345633", "none", 1, "toolName", layerTools, false);
        createPath(`M${rotation2.x} ${rotation2.y} A60 60 0 0 ${a} ${rotation4.x} ${rotation4.y} A60 60 0 0 ${a} ${rotation1.x} ${rotation1.y} L${tool.points[1].x} ${tool.points[1].y}`, "#56123433", "none", 1, "toolName", layerTools, false);
        createOrUpdateText("angText", rotation3, "#123456", layerTools, angleNum + "&deg;");
        createOrUpdateText("altAngText", rotation4, "#561234", layerTools, angleNumAlt + "&deg;");
    }else if(toolName=="rectangularGrid"){
        rectangularGridContainer.setAttribute("class", "show");
        isometricGridContainer.setAttribute("class", "hide");
        document.querySelector(".isometric-btn").classList.remove("group-btn-on"); 
        document.querySelector(".rectangular-btn").classList.add("group-btn-on");        
        createRectangularGrid();
    }else if(toolName=="getMeasurement"){ 
        const lineLength = niceNum(calculateDistance(tool.points[0], tool.points[1]));
        const lineAng = niceNum(lineAngle(tool.points[0], tool.points[1], true));
        const midPoint = findPointOnLine(tool.points[0], tool.points[1], 0.5)
        createOrUpdateText("angText", midPoint, appData.guideColour, layerTools, lineLength + "px | " + lineAng + "&deg;");
        createPath(tool.points, "none", appData.guideColour, 1, "toolName", layerTools, false); 
        createCircle("x", tool.points[0], guideHandleSize, "#123456", "none", 0, layerTools, "none");
        createCircle("x", tool.points[1], guideHandleSize, "#561234", "none", 0, layerTools, "none");
    }else if(toolName=="polystar"){
        let centroidPoint = getPolygonCentroid(tool.points);      
        if(sessionData.toolNodeIndex>tool.points.length-1){    
            let xAdjust = tool.centroid.x - centroidPoint.x; 
            let yAdjust = tool.centroid.y - centroidPoint.y;           
            tool.points = translateNodes(tool.points, xAdjust, yAdjust);
        }else{ 
            const nodeMoved = tool.points[sessionData.toolNodeIndex];         
            createCircle("x", nodeMoved, guideHandleSize, "#561234", "none", 0, layerTools, "none");
            const angle = 360/tool.sides;
            tool.points = [];
            let count = sessionData.toolNodeIndex;
            for(let i=0; i<tool.sides; i++){
                //re write starting with node at index eg 4 = [4]->[4,5]->[0,4,5]->[0,1,4,5]->[0,1,2,4,5]->[0,1,2,3,4,5]
                tool.points[getIndex(count, tool.sides)] = (rotatePoint(centroidPoint, nodeMoved, i*angle));
                count++    
            } 
        }    
        const star = makeStar(tool.points);
        changePolyStarQtyTxt.innerHTML = tool.sides;    
        createPath(star, "none", "#12345644", 1, "toolName", layerTools, true); 
        createPath(tool.points, "none", appData.guideColour, 1, "toolName", layerTools, true);
        centroidPoint = getPolygonCentroid(tool.points);
        createCircle("x", centroidPoint, guideHandleSize, "#561234", "none", 0, layerTools, "none");
        
    }     
}

function makeStar(pointList){
    const pointListLen = pointList.length;
    const newPointList = [];
    //rotate around 
    let count = 0;
    for(let i=0; i<pointList.length; i++){
        newPointList.push(pointList[getIndex(count, pointListLen)]);
        newPointList.push(pointList[getIndex(count+2, pointListLen)]);        
        count +=2;
        if(isEven(pointListLen) & i==(pointListLen*0.5)-1){
            count +=1;
        }
    }
    return newPointList;
}

function changeToolValue(toolName, propName, val, textId, isStandard){  
    const tool = getCurrentDesign().tools.find(x => x.name === toolName);  
    if(val!='update'){
        val = (isStandard)? tool[propName]+val:val;
        tool[propName] = val;
    }
    //custom-colour
    if(textId=="gridColourPicker" || textId=="rectGridColourPicker"){
        const colourValue = (val=='update')? tool[propName]:val;
        //console.log(textId, colourValue)
        changeColourValue(textId, colourValue);
    }else if(textId!=null & textId!="colour-input"){
        //console.log(textId)
        document.getElementById(textId).innerHTML = tool[propName];
    }      
    if(toolName=="centroid" || toolName=="polystar"){
        if(tool.sides==undefined || tool.sides==null){            
            tool.sides = 4;
        }
        if(tool.sides<3){
            tool.sides=3;
        }
        changePolyPointsBtn(toolName, textId); 
    }    
    if(val!='update'){
        makeTool(toolName);
    }
    saveLocalStorage();
}

function addIntersectLinesBtn(){
    //const tool = getCurrentDesign().tools.find(x => x.name === "intersectLines");
    const tool = getToolByName("intersectLines");    
    var design = getCurrentDesign(); 
    const visualCenter = getVisualCenter();
    const offset = 100;
    tool.points.push({x:visualCenter.x - offset, y:visualCenter.y - offset});
    tool.points.push({x:visualCenter.x - (offset*2), y:visualCenter.y - (offset*2)});
    makeTool("intersectLines")
}

function cloneArrayWithoutFirstElement(arr){
    let newArr = [...arr]
    return newArr.splice(0);
}

function changePolyPointsBtn(toolName, textId){
    const tool = getToolByName(toolName);
    document.getElementById(textId).innerHTML = tool.sides;
    const centroidPoint = getPolygonCentroid(tool.points); //getPolygonCentroid(cloneArrayWithoutFirstElement(tool.points));
    const newPointList = [];
    const angle = 360/tool.sides;
    for(let i=0; i<tool.sides; i++){
        point = rotateAroundPoint(centroidPoint, i*angle, 100);
        newPointList.push(point);        
    }        
    tool.points = newPointList;
    console.log(tool, tool.points)
}




/*
function findSnapBtn(){
    changeMode("tools");
    makeTool("snapPattern")
    const point = getCurrentTool().points[0];
    const snapPoint = findSnap(sessionData.snapPoints, point, point.id);
    if(snapPoint.id==point.id){
        console.log("not found");     
    }else{
        changeMode("patterns");
        sessionData.pointType = "patternPoint";
        sessionData.patternPointIndex = (snapPoint.p.y==0)? 0:1;  //p1 or p2
        movePoint(point.x-snapPoint.x, point.y-snapPoint.y, false); //move the pattern point
        redrawShapes();
        changeMode("tools");   
    }
    console.log(point.x-snapPoint.x, point.y-snapPoint.y);
    console.log(point.id, snapPoint.id, snapPoint.p, snapPoint);
    console.log(point, snapPoint);
}
*/

function getVisualCenter(){
    const design = getCurrentDesign();
    const topPanelHeight = 35;
    const height = Math.floor((100/design.zoom)*window.innerHeight)-topPanelHeight;
    const width = Math.floor((100/design.zoom)*sessionData.svgWidth);    
    const screenCenter = {x:width*0.5, y:height*0.5};
    const zoomCenter = {x:screenCenter.x + design.panLeft, y:screenCenter.y + design.panUp + window.pageYOffset}
    return zoomCenter;
}

function centerToolBtn(isMakeTool){ 
    const tool = getCurrentTool();
    const visualCenter = getVisualCenter();
    //createCircle("x", visualCenter, 2, "#ffcccc", "none", 0, layerPoints, "rotated-point");
    let xAdjust = visualCenter.x - tool.points[0].x; 
    let yAdjust = visualCenter.y - tool.points[0].y;           
    tool.points = translatePoints(tool.points, xAdjust, yAdjust);
    if(isMakeTool){
        makeTool(tool.name);
    }    
}
////////////////////////////////////////Tools End//////////////////////////////////////////////////
////////////////////////////////////////Background Start//////////////////////////////////////////////////
function getFileNameFromPath(filePath){
    const file = filePath.split("\\");
    return file[file.length-1];
}

function getImageFileName(filePath){
    fileData.value = getFileNameFromPath(filePath);
}

function changeBackgroundOpacity(val){
    getCurrentDesign().bgOpacity = val;
    var opacity = getCurrentDesign().bgOpacity/100;
    backgroundOpacityText.innerHTML = val + "%";
    backgroundOpacityRange.value = val;
    layerBackground.setAttribute("style", "opacity:" + opacity);
    saveAndUpdate();
}

function changeBackgroundTransform(){
    let aPoint = getCurrentDesign().points[0]
    backgroundImage.setAttribute("transform", "rotate(" + getCurrentDesign().bgRotate + " " + aPoint.x + " " + aPoint.y + ") scale(" + getCurrentDesign().bgZoom/100 + ")");
}

function changeBackgroundRotation(num){
    getCurrentDesign().bgRotate = num/10;
    backgroundRotationText.innerHTML = getCurrentDesign().bgRotate;
    backgroundRotationRange.value = num;
    changeBackgroundTransform();
    saveLocalStorage();
}

function changeBackgroundPosition(x, y, isIncrimental){
    getCurrentDesign().bgPosition.x += x;
    getCurrentDesign().bgPosition.y += y;
    saveLocalStorage();
}

function changeBackgroundZoom(num){
    //const rect = layerBackground.getBoundingClientRect();
    //console.log(rect.width, rect.height);
    if(num==undefined) num = 100;    
    getCurrentDesign().bgZoom = num;
    //backgroundImage.setAttribute("transform", "scale(" + num/100 + ")");
    changeBackgroundTransform();
    backgroundZoomRange.value = num;
    backgroundZoomText.innerHTML = num + "%";
    saveLocalStorage();
}

function changeBackgroundColor(hexColour){
    if(hexColour!=false){
        getCurrentDesign().backgroundColour = hexColour; //set data     
    }else{
        backgroundColourPicker.value = getCurrentDesign().backgroundColour; //update picker
    }
    const backgroundColor = getCurrentDesign().backgroundColour
    changeColourValue("backgroundColourPicker", backgroundColor);
    //backgroundColourPickerBtn.innerHTML = backgroundColor;
    //backgroundColourPickerBtn.setAttribute("style", `background-color: ${backgroundColor};`);
    designSvg.setAttribute("style", `background-color: ${backgroundColor};`);
    saveLocalStorage();
}

function loadBackgroundImage(){
    var design = getCurrentDesign();
    const bgImage = (design.image==undefined || design.image=="images/")? "":design.image;
    backgroundImage.setAttribute("href", bgImage);
}

////////////////////////////////////////Background End//////////////////////////////////////////////////
////////////////////////////////////////Start Pattern//////////////////////////////////////////////////

/*
function addPatternBtn(){
    getCurrentDesign().patternPoints.push(new Point(100, 100));
    saveAndUpdate();
    //createPointButtons();
    createPatternButtons();
}
*/

function createPatternButtons(){
    let htmlText = "";
    var design = getCurrentDesign();
    //remove null and undefined     
    design.patternPoints = filterEmptyFromArray(design.patternPoints);
    
    design.patternPoints.forEach(function(pattern, index){
        var colour = getHexColour(index+22); //offset to make stand out
        var className = (pattern==null || pattern==undefined)? "btn-off":"btn-on";
        var borderColour = (sessionData.patternPointIndex==index)? "#d1d1d1":colour;
        htmlText +=  '<button class="' + className + '" style="background-color:' + colour + '; border-color:' + borderColour + '; width:25px;" onclick="changePatternPointBtn(\'' + index + '\')">p' + (index+1) + '</button>'; 
    });
    
    patternButtons.innerHTML = htmlText; // + '<button onclick="addPatternBtn()">+</button>';
}

function changePatternPointBtn(index){
    updateMode("patterns");
    sessionData.pointType = "patternPoint"
    sessionData.patternPointIndex = index;
    createPatternButtons();
    updatePoints();
    redrawShapes();
    const id = "p" + (Number(index)+1); 
    createAnimation(id, "r", "0;7;0", 1, 2);
}

function clearShapeBtn(){
    var shape = getCurrentShape();
    shape.data = [];
    shapeData.value = "";
    saveAndUpdate();
}

////////////////////////////////////////Pattern End//////////////////////////////////////////////////
////////////////////////////////////////Points Start//////////////////////////////////////////////////
function getPoint(id){
    var point = appData.designs[appData.designIndex].points[id];
    //create if none
    if(point==undefined){
        appData.designs[appData.designIndex].points[id] = new Point(100, 100);
        point = appData.designs[appData.designIndex].points[id];        
    }
    return point;
} 

function getCurrentPoint(){
    return getPoint(sessionData.pointIndex);
}

function getPointFromLetter(letter){
    return getCurrentDesign().points.find(point => point.letter === letter);
}



function updatePointLengthAndAngles(){
   const design = getCurrentDesign();
   for(const point of design.points){
        const cent = getPoint(point.connect);
        point.length = niceNum(calculateDistance(cent, point, true));  
        point.angle = niceNum(lineAngle(cent, point, true)); 
   }
   //update pattern points 
   for(const point of design.patternPoints){
        const cent = design.points[0];
        point.length = niceNum(calculateDistance(cent, point, true));  
        point.angle = niceNum(lineAngle(cent, point, true)); 
   }   
}


function changePointProperty(propName, val, isIncrimental, textId){
    const point = getCurrentPoint(); 
    val = (isIncrimental)? point[propName]+val:val;
    if(propName==="rounding"){ //floating point number precision 3.0000000000000009
        val = Number(parseFloat(val).toPrecision(1));
    }    
    point[propName] = val;
    const el = document.getElementById(textId);
    if(el!=null){
        el.innerHTML = val;
    }    
    changePointBtn(sessionData.pointIndex);
    redrawShapes();
    saveLocalStorage();
}

function changeConnect(connectIndex){
    const point = getCurrentPoint();
    const connected = point.connect;
    const pointIndex = sessionData.pointIndex
    connectIndex = (connectIndex=='self')? pointIndex:connectIndex;
    connectIndex = (connectIndex=='previous')? pointIndex -1:connectIndex;    
    //remove old path;
    var id = `line_${sessionData.pointIndex}_${connected}`;
    var el = document.getElementById(id);
    if(el!=null){
        el.remove();        
    } 
    point.connect = Number(connectIndex);       
    connectSelect.value = connectIndex;
    saveAndUpdate();
}

function makeRotationBtns(){
    let angles = [0,3,6,12];
    //if(anglesList!=null) angles = angles.concat(anglesList);
    angles = angles.sort(function (a, b) {  return a - b;  });
    let htmlText = "";    
    angles.forEach(function(angle){
        htmlText += '<button onclick="changeRotation(' + angle + ', false)">' + angle + '</button>';
    });
    rotationBtns.innerHTML = htmlText;
}

function createRotatedPoints(index){
    if(index==0){
        clearLayers(false, true);
        sessionData.rotatedPoints = [];
    }
    let point = getPoint(index);
    //var cent = getPoint(0); //assumes first point
    var cent = getPoint(point.connect);
    if(point.rotation==0) return false;    
    var angle = 360/point.rotation;
    for(var i=1; i<point.rotation; i++){
        var id = letters[index] + i;
        let rotatedPoint = rotatePoint(cent, point, (i*angle));
        var el = document.getElementById(id);
        if(el!=null){
            el.setAttribute("cx", rotatedPoint.x);
            el.setAttribute("cy", rotatedPoint.y);
        }else{
            createCircle(id, rotatedPoint, 1, getHexColour(index), "none", 0, layerRotatedPoints, "rotated-point");
            sessionData.rotatedPoints.push({x:rotatedPoint.x, y:rotatedPoint.y, id:id})
        }
    }
}
  
function updatePoint(pos, index){    
    sessionData.updating = true;
    var id = letters[index] + "0";
    var el = document.getElementById(id);
    var elHalo = document.getElementById(id + "_halo");    
    const point = getPoint(index)     
    
    //create if not there
    if(point==undefined){        
        appData.designs[appData.designIndex].points[index] = new Point(pos.x, pos.y);        
    }
    var pointConnect = point.connect;
    var connectedPoint = appData.designs[appData.designIndex].points[pointConnect];
    if(connectedPoint==undefined){
        appData.designs[appData.designIndex].points[pointConnect] = new Point(pos.x, pos.y);  
    }
    createOrUpdateCircle(id, index, index, pos, "control-point", 1, "none", 0, layerPoints)
    createOrUpdateCircle(id + "_halo", index, -1, pos, "control-point", 6, getHexColour(index) + "22", 4, layerPoints)
    createRotatedPoints(index);
    //updateLine
    var id = `line_${index}_${pointConnect}`;
    var el = document.getElementById(id);
    
    if(el!=null){
        var path = createPathString([pos, connectedPoint]);
        el.setAttribute("d", path); //remove();        
    }
    
    var length = calculateDistance(pos,connectedPoint,true);
    var angle = lineAngle(connectedPoint, pos, true);
  
    //update app data    
    point.x = niceNum(pos.x);
    point.y = niceNum(pos.y);
    point.length = niceNum(length);
    point.angle = niceNum(angle);
    
    //update nav bar for current point
    //console.log(sessionData.pointIndex, index, !sessionData.drag)
    if(sessionData.pointIndex == index & !sessionData.drag){
        
        //letterText.innerHTML = letters[index];
        //letterText.style.backgroundColor = getHexColour(index);
        xText.innerHTML = pos.x;
        yText.innerHTML = pos.y;
        connectSelect.value = pointConnect;
        if(point.pair==undefined) point.pair=-1; 
        pairPointsSelect.value = point.pair;
        rotationText.innerHTML = point.rotation;
        angleText.innerHTML = point.angle;
        lengthText.innerHTML = point.length;
        const rotationAngle = 360/point.rotation;
        if(rotationAngle!=Infinity){
            const rotationList = [niceNum(rotationAngle*0.25,1), niceNum(rotationAngle*0.5,1), niceNum(rotationAngle,1)];
            rotationInfo.innerHTML = 
            '<a href="#" onclick="changeRotation(' + rotationList[0] + ', false)">' + rotationList[0] + '</a> : ' +
            '<a href="#" onclick="changeRotation(' + rotationList[1] + ', false)">' + rotationList[1] + '</a> : ' +
            '<a href="#" onclick="changeRotation(' + rotationList[2] + ', false)">' + rotationList[2] + '</a>'; 
            makeRotationBtns();
        }else{
            makeRotationBtns();
        }
        
    }    
    sessionData.updating = false;
}

function movePoint(x, y, absolutePosition){
    let currentPointPosition = {x:0, y:0};  
    updateTopInfoPanel("moving point");
    if(sessionData.mode=="tools"){
        console.log("move point", sessionData.toolPointIndex)
    }else if(sessionData.mode=="patterns"){
        var point = getCurrentDesign().patternPoints[sessionData.patternPointIndex];
    }else if(sessionData.mode=="crop"){
        var point = getCurrentDesign().cropPoints[sessionData.cropPointIndex];
        if(!sessionData.updating) updateCrop(); //do before draw point        
    }else{ //if(sessionData.pointType=="point")
        var point = getCurrentPoint();
        if(point.isLocked){
            updateTopInfoPanel("point is locked, unlock to move..."); 
            return false;
        }
        //move paired point
        if(point.pair!=-1){
            currentPointPosition = {x:point.x, y:point.y}         
        }
    }
    
    //console.log(sessionData.mode, "move point", sessionData.cropPointIndex)
    
    if(absolutePosition){
        point.x = niceNum(x);
        point.y = niceNum(y);    
    }else{
        point.x += x;
        point.y += y;
    }  

    //move paired point
    if(sessionData.pointType=="point" & point.pair!=-1){
        const pairedPoint = getPoint(point.pair);
        pairedPoint.x = pairedPoint.x + (point.x - currentPointPosition.x);
        pairedPoint.y = pairedPoint.y + (point.y - currentPointPosition.y);    
    }
    
    saveAndUpdate();
    
    if(sessionData.mode=="crop"){ 
        updateCrop();
    }else if(sessionData.mode=="patterns" || sessionData.mode=="points"){
        redrawShapes();
    }else if (sessionData.mode=="tools"){
        makeTool(getCurrentTool().name);
    }   
}

function getNextLetter(){
    var lettersClone =  [...letters];
    getCurrentDesign().points.forEach(function(point, index){
        if(point!=null){
            if(lettersClone.includes(point.letter)){
               lettersClone[index] = 0; 
            } 
        }        
    });
    lettersClone = lettersClone.filter(el => el !== 0);     
    return lettersClone[0]
}

function addPointBtn(){
    updateMode("add point");
    updateTopInfoPanel("To add point click on design area");   
}

function updatePoints(){
    getCurrentDesign().points.forEach(function(val, index){    
        if(val!=null){
            updatePoint({x:val.x, y:val.y}, index);
        }  
    });    
    getCurrentDesign().patternPoints.forEach(function(val, index){    
        if(val!=null){
            createOrUpdateCircle("p" + (index+1), index, index+22, val, "none", 2, "none", 0, layerPattern); 
            createOrUpdatePath(polyShapePath(val, 6, 6, 30), "none", getHexColour(index+22) + "33", 2, "p" + (index+1) + "_halo", layerPattern, true);                 
        }  
    });
    
    //console.log(getCurrentDesign().cropPoints)
    getCurrentDesign().cropPoints.forEach(function(val, index){    
        if(val!=null){
            //console.log(val)
            createOrUpdateCircle("crop" + index, index, index+22, val, "none", 2, "none", 0, layerCrop); 
        }  
    });    
}

function lockUnlockPoint(){
    point = getCurrentPoint();
    point.isLocked = !point.isLocked;
    saveLocalStorage();
    createPointButtons();
    lockBtn.innerHTML = (point.isLocked)? "unlock":"lock";
}


function lockUnlockShape(){
    shape = getCurrentShape();
    shape.isLocked = !shape.isLocked;
    saveLocalStorage();
    createShapeButtons();
    lockShapeBtn.innerHTML = (shape.isLocked)? "unlock":"lock";
}



function createPointButtons(){
    let htmlText = "";
    let htmlText2 = "";
    let selectHtml = "";
    let design = getCurrentDesign();
    //remove null and undefined
    design.points = filterEmptyFromArray(design.points);    
    design.points.forEach(function(point, index){
        let colour = getHexColour(index);
        let className = (point==null || point==undefined)? "btn-off":"btn-on";
        let borderColour = (sessionData.pointIndex==index)? "#d1d1d1":colour;
        if(point.isLocked){
            className += " locked" 
        }        
        htmlText +=  '<button class="' + className + '" style="background-color:' + colour + '; border-color:' + borderColour + '" onclick="changePointBtn(' + index + ')">' + point.letter + '</button>';
        selectHtml += '<option value="' + index + '">' + point.letter + '</option>';
    });
    
    pointButtons.innerHTML = htmlText + '<button onclick="addPointBtn()">+</button>';
    connectSelect.innerHTML = selectHtml;
    pairPointsSelect.innerHTML = selectHtml;
}

function changePointBtn(index){
    updateMode("points");
    sessionData.pointIndex = index;
    const point = getCurrentPoint();
    createPointButtons();
    updatePoints();
    roundingText.innerHTML = point.rounding;
    roundingWeightText.innerHTML = point.roundingWeight;
    lockBtn.innerHTML = (point.isLocked)? "unlock":"lock";
    createAnimation(point.letter + "0", "r", "0;7;0", 1, 2);
}

function clearPoint(){
    appData.designs[appData.designIndex].points[sessionData.pointIndex] = null;
    saveAndUpdate();    
}
////////////////////////////////////////Points End//////////////////////////////////////////////////
////////////////////////////////////////Local Storage Start//////////////////////////////////////////////////
function compareAndUpdateObjectKeys(firstObj, secondObj, updateSecond){
    let keyArray = [];
    for (var key in firstObj){
        if(secondObj.hasOwnProperty(key)){
            //console.log("hasProp:", key);
        }else{
            //console.log("notProp:", key);
            if(updateSecond){
                console.log("update key:", key, firstObj[key])
                secondObj[key] = firstObj[key];
            }
        }
    }
    console.log(secondObj);
}

function cloneObject(obj){
    //const clone = Object.assign({}, obj); //shallow
    const clone = JSON.parse(JSON.stringify(obj)); //deep
    //const clone = structuredClone(obj); //deep
    return clone
}

function removeEmptyShapes(){
    for(var i=0; i<appData.designs.length; i++){
        let shapes = appData.designs[i].shapes;
        shapes.forEach(function(shape, index){               
            if(shape==null || shape.data.length==0){
                //console.log(shape);
                shapes.splice(index, 1);
            } 
        });
    }
}

function saveLocalStorage(){
    //console.log("saving local storage");
    //const clone = cloneObject(appData);    
    localStorage.setItem("svginteractive", JSON.stringify(appData));
}

function getLocalStorage(){
    const retrievedObject = localStorage.getItem("svginteractive");
    const retrievedObjectJson = JSON.parse(retrievedObject);
    if(retrievedObjectJson==null){
        appData.designs[0].points.push(new Point(400, 400));
        saveLocalStorage();
    }else{
        appData.designIndex = retrievedObjectJson.designIndex;
        appData.designs = retrievedObjectJson.designs;
        appData.guideColour = retrievedObjectJson.guideColour;
        appData.guideHandleSize = 2;
        removeEmptyShapes();         
        //update design 
        appData.designs.forEach(function(design, index){
            //design.points = design.points;
            //design.patternPoints = design.patternNodes;
            //design.cropPoints = design.cropNodes;
            
            //update tools
            design.tools.forEach(function(tool, index){  
                //const toolPoints = cloneObject(tool.points);
                //const toolNodes = cloneObject(tool.nodes);
                
                //tool.points = toolNodes;
                //tool.nodes = toolPoints;                
            });       
            
            //design.articulateCurve = 2;
            //design.isArticulated = false;
            //update points
            design.points.forEach(function(point, index){  
                //point.rounding = 0;
                //point.roundingWeight = 0;
            });     
                        
            //update points
            design.points.forEach(function(point, index){  
                //point.rounding = 0;
                //point.roundingWeight = 0;
            });     
            
            //update shapes
            design.shapes.forEach(function(shape, index){  
            
            });
        
        });
        
   
        
        
        
        
            //delete appData.designs[i].toolInfo;
            //appData.designs[i].tools =  []; 
            //appData.designs[i].shapeRenderType = "repeat";
            
            //appData.designs[i].bgRotate = 0;
            //appData.designs[i].bgPosition = {x:0, y:0};
            
            //let shapes = appData.designs[i].shapes;
            //points.forEach(function(points, index){               
                //if(shape==null || shape.data.length==0){
                    //console.log(shape);
                    //shapes.opacity = 30;
                    //shape.fillOpacity = 30;
                    //shape.strokeOpacity = 100;
                    
                //} 
            //});            
        //}

        //appDataCopy = Object.create(appData);

        //resetIndexes();        
        //getNextLetter();        
        //compareAndUpdateObjectKeys(retrievedObjectJson, appData2, true) 

        
        saveLocalStorage();
    }
}
////////////////////////////////////////Local Storage End//////////////////////////////////////////////
////////////////////////////////////////Shapes Start //////////////////////////////////////////////////
function getShape(id){
    var shape = getCurrentDesign().shapes[id];
    return shape; 
}

function getCurrentShape(){
    return getShape(sessionData.shapeIndex);
}

function changeShapeProperty(propName, val, isIncrimental){
    let shape = getCurrentShape();    
    if(val!='update'){
        val = (isIncrimental)? shape[propName]+val:val;
        shape[propName] = val;        
        changeShape(sessionData.shapeIndex);
    }      
}

function translatePoints(pointList, xAdjust, yAdjust){
    return pointList.map(points => ({x:points.x+xAdjust, y:points.y+yAdjust, id:points.id}));
}

function changeShape(val){
    updateMode("shapes");
    sessionData.shapeIndex = Number(val);
    let shape = getCurrentShape();
    if(shape==undefined){
        return false;
    }
    shapeData.value = shape.data.toString();
    shapeRotationText.innerHTML = shape.rotation;    
    fillOpacityText.innerHTML = shape.fillOpacity;
    strokeOpacityText.innerHTML = shape.strokeOpacity;     
    updateSkip(shape);    
    createShapeButtons();
    redrawShapes();
    changeColourValueBasic('shapeFillPickerBtn', shape.fill);
    changeColourValueBasic('shapeStrokePickerBtn', shape.stroke);
    lockShapeBtn.innerHTML = (shape.isLocked)? "unlock":"lock";  
    saveLocalStorage();
    createAnimation("shape_" + val + "_0", "stroke-width", "1;7;1", 1, 2);    
}

function clearShapes(){
    layerShapes.innerHTML = "";
    sessionData.rotatedShapes = [];
}

function getShapePath(index){
    var shape = getShape(index);
    var path = [];
    shape.data.forEach(function(cnr, index){
        if(cnr!=''){
            var match = cnr.match(/([a-z])(\d+)/);
            //console.log(index,match,cnr)
            var i = letters.indexOf(match[1]);
            let centerPoint = getPoint(getPoint(i).connect);
            var rotation = Number(match[2]); //how many times to rotate b3 = three times
            var point = getPoint(i);
            var rot = 360/point.rotation;
            if(rotation==0){
                path.push({x:point.x, y:point.y, id:match[1], rounding:point.rounding, roundingWeight:point.roundingWeight});
            }else{        
                const rotatedPoint = rotatePoint(centerPoint, point, rot*rotation);
                path.push({x:rotatedPoint.x, y:rotatedPoint.y, id:match[1], rounding:point.rounding, roundingWeight:point.roundingWeight});   
            }
        }
    });  
    return path;
}

function getArticulatedPoints(a, b, c){ //will be a, b, c, (2,3,4)
    const design = getCurrentDesign();
    //work out percentage of line based on detail
    const percentage = 1/design.articulateCurve;
    const articulatedPoints = [];
    for(var i=0; i<design.articulateCurve; i++){    
        const lineAb1 = findPointOnLine(a, b, percentage*i);
        const lineBc1 = findPointOnLine(b, c, percentage*i);
        const lineAb2 = findPointOnLine(a, b, percentage*(i+1));
        const lineBc2 = findPointOnLine(b, c, percentage*(i+1));
        const intersectPoint = lineIntersect(lineAb1, lineBc1, lineAb2, lineBc2, false);
        articulatedPoints.push(intersectPoint);
    }    
    return articulatedPoints;
}



function getCornerWeight(a,b,c, weight){ //a, b, c
    const lineAb = lineAngle(a, b, false);
    const linebC = lineAngle(c, b, false);
    const midAngle = (lineAb + linebC) * 0.5;
    const cornerWithWeight = rotateAroundPoint(b, midAngle, weight)
    //createCircleSimple(cornerWithWeight, "", layerPoints, "#000"); 
    return cornerWithWeight;
}

function articulatePoints(pointList){
    //console.log(pointList)
    const cloneList = cloneObject(pointList)
    let newPointList = [];
    //remove if first and last the same
    if((cloneList[0].x==cloneList[cloneList.length-1].x) & (cloneList[0].y==cloneList[cloneList.length-1].y)){
        cloneList.pop();
    }
    const pointListLength = cloneList.length;
    const intermediatePoints = [];
    
    cloneList.forEach(function(point, index){    
        const pointPrev = cloneList[getIndex(index-1, pointListLength)];
        const pointNext = cloneList[getIndex(index+1, pointListLength)];
        if(point.rounding+pointPrev.rounding>1){
            point.rounding = 0.5;
            pointPrev.rounding = 0.5;
        }        
        if(point.rounding+pointNext.rounding>1){
            point.rounding = 0.5;
            pointNext.rounding = 0.5;
        } 
        
        
        if(point.rounding!=0){
            var intPoint = findPointOnLine(point, pointNext, point.rounding);
        }else{
            var intPoint = findPointOnLine(point, pointNext, 1-pointNext.rounding);
        }
        
        //let intPoint1 = findPointOnLine(pointPrev, point, point.rounding);
        //let intPoint = findPointOnLine(point, pointNext, point.rounding);
        intermediatePoints.push(intPoint);
        //createCircleSimple(intPoint1, "", layerPoints, "#000")
        //createCircleSimple(intPoint, "", layerPoints, "#000")
        //createCircleSimple(point, "", layerPoints, "#123456")
        
        
    });
    
    //console.log(intermediatePoints)
    
    newPointList.push(intermediatePoints[0]); 
    
    for(let i=0; i<pointListLength; i++){
        //start 1
        const point = cloneList[getIndex(i+1, pointListLength)];
        const startPoint = intermediatePoints[getIndex(i, pointListLength)];
        const endPoint = intermediatePoints[getIndex(i+1, pointListLength)];
    
        if(point.rounding!=0){
            const weightedPoint = getCornerWeight(startPoint, point, endPoint, point.roundingWeight);
            const articulatedPoints = getArticulatedPoints(startPoint, weightedPoint, endPoint);
            newPointList = newPointList.concat(articulatedPoints); 
        }else{
            newPointList.push(point)
        }  
        
    
    }
    
    newPointList.push(intermediatePoints[0]); 
    
    
     
    /*
    cloneList.forEach(function(point, index){
        if(point.rounding!=0){
            const percentage2 = point.rounding;
            const percentage1 = 1-percentage2;
            
            //if the last point is same as first
            //let prevIndex = (index==0 & firstAndLastSame)? getIndex(index-2, pointListLength):getIndex(index-1, pointListLength);
            const pointPrev = cloneList[getIndex(index-1, pointListLength)];
            const pointNext = cloneList[getIndex(index+1, pointListLength)];
            
            
            const artPoint1 = findPointOnLine(pointPrev, point, percentage1);    
            const artPoint2 = findPointOnLine(point, pointNext, percentage2);

            //add point weighting
            const weightedPoint = getCornerWeight(pointPrev, point, pointNext, point.roundingWeight);
           //const articulatedPoints = getArticulatedPoints(pointPrev, weightedPoint, pointNext);
            const articulatedPoints = getArticulatedPoints(artPoint1, weightedPoint, artPoint2);
            
            newPointList = newPointList.concat(articulatedPoints);          
        }else{
            newPointList.push(point)
        }    
    });
    */
    //the first becomes last
    //newPointList[newPointList.length-1] = newPointList[0];
    
    

    //console.log(newPointList)
    return newPointList;
}

function rotateShape(path, shape, shapeIndex, cent, x, y){
    var rot = 360/shape.rotation;
    for(var i=0; i<shape.rotation; i++){ 
        if(!shape.skip.includes(i)){
            var newPath = [];
            path.forEach(function(cnr, index){
                const rotatedPoint = rotatePoint(cent, cnr, rot*i);
                newPath.push(rotatedPoint);
                if(x<3 & y<3){
                    //createCircleSimple(rotatedPoint, cnr.id + i + "_" + x + "_" + y, layerShapes);
                    sessionData.snapPoints.push({x:rotatedPoint.x, y:rotatedPoint.y, id:cnr.id + index, p:{x:x,y:y}});
                }
            });
            const pathId = "shape_" + shapeIndex + "_" + i;
            
            //if current Shape draw custom opacity
            if(sessionData.shapeIndex==shapeIndex || sessionData.mode!="shapes"){
                createPath(newPath, shape.fill + getHexOpacity(shape.fillOpacity), shape.stroke + getHexOpacity(shape.strokeOpacity), 1, pathId, layerShapes, false);
            }else{
                let hexOpacity = percentageToHexAlpha(sessionData.unselectedShapesOpacity);
                createPath(newPath, shape.fill + hexOpacity, shape.stroke + hexOpacity, 1, pathId, layerShapes, false);
            }
            sessionData.rotatedShapes.push(newPath);            
        }
    }     
}

function drawRotatedShapes(xAdjust, yAdjust, a, x, y){
    const design = getCurrentDesign()
    let cent = {x:a.x + xAdjust, y:a.y + yAdjust};
    getCurrentDesign().shapes.forEach(function(shape, index){
        if(shape!=undefined){
            let path = getShapePath(index);
            if(design.isArticulated){
                path = articulatePoints(path);
            }             
            path = translatePoints(path, xAdjust, yAdjust);  
            rotateShape(path, shape, index, cent, x, y);        
        }
    });
}

function makeShapeBtn(){
    const design = getCurrentDesign();
    design.shapeRenderType = "make";
    updateShapeBtns();
    clearShapes();
    design.shapes.forEach(function(shape, index){
        if(shape!=undefined){
            var shape = getShape(index);
            var path = getShapePath(index);
            if(design.isArticulated){
                path = articulatePoints(path);
            }            
            if(sessionData.shapeIndex==index || sessionData.mode!="shapes"){
                createPath(path, shape.fill + getHexOpacity(shape.fillOpacity), shape.stroke + getHexOpacity(shape.strokeOpacity), 1, "shape_" + index, layerShapes, false);
            }else{
                let hexOpacity = percentageToHexAlpha(sessionData.unselectedShapesOpacity);
                createPath(path, shape.fill + hexOpacity, shape.stroke + hexOpacity, 1, "shape_" + index, layerShapes, false);
            }
        }        
    });
    saveLocalStorage();
}

function rotateShapesBtn(){
    let design = getCurrentDesign();
    design.shapeRenderType = "rotate";
    updateShapeBtns();
    clearShapes();
    design.shapes.forEach(function(shape, index){
        if(shape!=undefined){
            let path = getShapePath(index);
            if(design.isArticulated){
                path = articulatePoints(path);
            }  
            rotateShape(path, shape, index, getPoint(0), 0, 0);        
        }
    });
    saveLocalStorage();
}


function repeatShapesBtn(){
    getCurrentDesign().shapeRenderType = "repeat";
    updateShapeBtns();
    clearShapes();
    sessionData.snapPoints = [];
    //var patternLetterId = [22,23,24];
    var xRepeat = getCurrentDesign().xRepeat; 
    var yRepeat = getCurrentDesign().yRepeat;
    var pointList = getCurrentDesign().points;
    var patternPoints = getCurrentDesign().patternPoints;
    var a = pointList[0];
    var w = patternPoints[0];
    var x = patternPoints[1];   
    var xPatternDistance = w.x - a.x; //true for all lines
    var yPatternDistance = x.y - a.y; //true for all lines
    var evenRowStart = x.x - a.x;
    for(var y=0; y<yRepeat; y++){
        yAdjust = yPatternDistance * y;
        xAdjust = isEven(y)? 0:evenRowStart;        
        for(var x=0; x<xRepeat; x++){            
            drawRotatedShapes(xAdjust, yAdjust, a, x, y);    
            xAdjust += xPatternDistance;    
        } //end x        
    } //end y
    saveLocalStorage();
}


function repeatShapesBtnNew(){
    getCurrentDesign().shapeRenderType = "repeat";
    updateShapeBtns();
    clearShapes();
    sessionData.snapPoints = [];
    //var patternLetterId = [22,23,24];
    var xRepeat = getCurrentDesign().xRepeat; 
    var yRepeat = getCurrentDesign().yRepeat;
    var pointList = getCurrentDesign().points;
    var patternPoints = getCurrentDesign().patternPoints;
    var a = pointList[0];
    var w = patternPoints[0];
    var x = patternPoints[1];   
    var xPatternDistance = w.x - a.x; //true for all lines
    var yPatternDistance = x.y - a.y; //true for all lines
    var evenRowStart = x.x - a.x;
    for (var y=0; y<yRepeat; y++){
        var yAdjust = yPatternDistance * y;
        if(isEven(y)) {
            var xAdjust = evenRowStart;
            for (var x=0; x<xRepeat; x++) {
                drawRotatedShapes(xAdjust, yAdjust, a, x, y);
                xAdjust += xPatternDistance;
            }
        } else {
            var xAdjust = (xRepeat-2) * xPatternDistance;
            for (var x=0; x<xRepeat; x++) {
                drawRotatedShapes(xAdjust, yAdjust, a, x, y);
                xAdjust -= xPatternDistance;
            }
        } //end x        
    } //end y
    saveLocalStorage();
}


function radialRepeatShapesBtn(){
    layerShapes.innerHTML = "";
    let design = getCurrentDesign();
    design.shapeRenderType = "radial";
    let connectList = [];
    let positionList = [[],[]];      
    let shapeIndex = 2;
    let shape = design.shapes[shapeIndex];
    let letter = shape.data[0].charAt(0);
    //get the connect point
    let connectPoint = getPointFromLetter(letter); //in this case d from d0
    console.log(connectPoint, {id:connectPoint.letter, connect:connectPoint.connect, rotation:connectPoint.rotation})
    connectList.push(connectPoint);
    
    let connect = 1;
    while (connect!=0) {
        connectPoint = design.points[connectPoint.connect];
        connectList.push(connectPoint);
        connect =  connectPoint.connect;   
    }
    connectList.reverse();
    
    connectList.forEach(function(point, index){
        let connectedPointCenter = getPoint(point.connect);
        let radius = calculateDistance(point, connectedPointCenter, true);
        if(index==0){ //first
            //create positions based on rotation
            for(let i=0; i<point.rotation; i++){
                let pointRotation = (360/point.rotation) * i
                let rotatedPoint = rotatePoint(getPointFromLetter("a"), point, pointRotation);
                rotatedPoint.rotation = pointRotation;                
                positionList[0].push(rotatedPoint);               
            }           
        }else if(index==connectList.length-1){ //last, render shape
            let shapePathList = getShapePath(shapeIndex);
            //console.log(getShapePath(shapeIndex), point);         
            for(let i=0; i< positionList[0].length; i++){
                let translatePos = positionList[0][i];
                //what is difference between connectedPointCenter and new position
                let xAdjust = translatePos.x - connectedPointCenter.x; 
                let yAdjust = translatePos.y - connectedPointCenter.y;           
                //translate shape to new center
                let shapePathListTranslated = translatePoints(shapePathList, xAdjust, yAdjust);
                createPath(shapePathListTranslated, shape.fill + getHexOpacity(shape.fillOpacity), shape.stroke + getHexOpacity(shape.strokeOpacity), 1, "shape_" + index, layerShapes, false);
            }            
        }else{
            //create positions based on previous positionList and current rotation
            for(let i=0; i< positionList[0].length; i++){ //mid
                let translatePos = positionList[0][i];
                for(let j=0; j<point.rotation; j++){
                    let pointRotation = (360/point.rotation) * j;
                    let combinedRotation = (pointRotation + translatePos.rotation) % 360; //keep under 360
                    let rotatedPoint = rotateAroundPoint(translatePos,  combinedRotation, radius);
                    rotatedPoint.rotation = combinedRotation;  
                    //createCircleSimple(rotatedPoint, "", layerCrop);  
                    positionList[1].push(rotatedPoint);               
                }  
            }
            positionList[0] = positionList[1];
            positionList[1] = [];
        }
    });
    saveLocalStorage();
}

function createShapeButtons(){
    var htmlText = "";
    getCurrentDesign().shapes.forEach(function(shape, index){
        //var colour = getHexColour(index);
        const colour = shape.fill;
        const borderColour = (sessionData.shapeIndex==index)? "#d1d1d1":colour;            
        const className = (shape.isLocked)? "btn-on locked":"btn-on"; 
        htmlText +=  '<button class="' + className + '" style="background-color:' + colour + '; border-color:' + borderColour + '" onclick="changeShape(' + index + ')">' + (index+1) + '</button>';
    });
    shapeButtons.innerHTML = htmlText + '<button onclick="addShapeBtn()">+</button>';
}

function addShapeBtn(){
    //add new
    getCurrentDesign().shapes.push(new Shape());
    //get index
    sessionData.shapeIndex = getCurrentDesign().shapes.length-1;
    changeShape(sessionData.shapeIndex);
    createShapeButtons();
    saveAndUpdate();
}

function updateShape(){
    var shape = getCurrentShape();
    var shapeDataVal = shapeData.value;
    var shapeDataNew = (shapeDataVal=="")? []:shapeDataVal.split(',');
    shapeDataNew = shapeDataNew.filter(n => n); //filter out empty
    shape.data = shapeDataNew;
    changeShape(sessionData.shapeIndex);
    saveLocalStorage();
}

function removeLastShapeBtn(){
    var shape = getCurrentShape();
    shape.data.pop();
    saveLocalStorage();
    changeShape(sessionData.shapeIndex);
}

function changeShapeRotation(val, standard){
    var shape = getCurrentShape();
    val = (standard)? shape.rotation+val:Number(val);
    shape.rotation = val;
    shapeRotationText.innerHTML = val;
    redrawShapes();
    saveLocalStorage();
}

function updateSkip(shape){
    var btnHTML = ""
    for(var i=0; i<shape.rotation; i++){
         var className = (shape.skip.includes(i))? "btn-off":"btn-on";   
         btnHTML += '<button onclick="changeSkipBtn(' + i + ')" class="' + className + '">' + i + '</button>'
    }
    skipBtnContainer.innerHTML = btnHTML;
}

function changeSkipBtn(val){
    var shape = getCurrentShape(); 
    var skip = shape.skip;
    var index = skip.indexOf(val);
    if(index==-1){
       shape.skip.push(val);
       shape.skip.sort();        
    }else{
        shape.skip.splice(index, 1);
    }
    updateSkip(shape);
    redrawShapes();
    saveLocalStorage();
}

function getBoundingBox(path) {
    return path.getBBox();
}

function sortPaths(layer){
    // Get all paths in the shapeLayer
    let paths = Array.from(layer.getElementsByTagName('path'));
    // Sort the paths by the top-left corner of their bounding boxes
    paths.sort((a, b) => {
        let bboxA = getBoundingBox(a);
        let bboxB = getBoundingBox(b);
        if (bboxA.y === bboxB.y) {
            return bboxA.x - bboxB.x;
        }
        return bboxA.y - bboxB.y;
    });
    // Clear
    layer.innerHTML = "";
    // Append paths in sorted order to the SVG
    paths.forEach(path => {
        layer.appendChild(path);
    });
    
    paths = Array.from(layer.getElementsByTagName('path'));
    let prevPoint = 0;
    let tempPaths = [];
    let newPaths = [];
    let isEven = true;
    paths.forEach(path => {
        let point = getBoundingBox(path).x;
        const direction = (prevPoint<point)? "left":"right";      
        if(direction==="right"){
            isEven = !isEven;
            if(isEven){
                if(tempPaths.length!=0){
                    newPaths = newPaths.concat(tempPaths);
                    tempPaths = [];
                }    
            }    
        }         
        //reverse the direction for every odd line, lines start at 0, 0 is even;
        //first Right
        if(isEven){
            newPaths.push(path);     
        }else{
            tempPaths.unshift(path)
        }
        console.log(point, direction, isEven)
        prevPoint = point;
    }); 

    layer.innerHTML = "";
    
    
    // Append paths in sorted order to the SVG
    newPaths.forEach(path => {
        layer.appendChild(path);
    });
    
}





////////////////////////////////////////Shapes End/////////////////////////////////////////////////
////////////////////////////////////////Crop Start//////////////////////////////////////////////////
function changeOutlineWidth(val){
    getCurrentDesign().outlineWidth += val;    
    outlineWidthText.innerHTML = getCurrentDesign().outlineWidth;
    saveLocalStorage();
}

function outlinePoints(pointListSrc, outside, width, closed){
    const pointList = Object.create(pointListSrc);
    //remove last as the same as first
    if(closed) pointList.pop(); 

    //console.log(closed)
    const angleAddition = (outside)? 90:-90;
    const loopAddition = (closed)? 1:-1;
    const pointListNew = [];
    const pointListLen = pointList.length;
    
    for(var i=0; i<(pointListLen+loopAddition); i++){
    //for(var i=0; i<pointListLen; i++){
        var firstPoint = pointList[getIndex(i, pointListLen)];
        var secondPoint = pointList[getIndex(i+1, pointListLen)];
        var thirdPoint = pointList[getIndex(i+1, pointListLen)];
        var fourthPoint = pointList[getIndex(i+2, pointListLen)];
        
        //console.log(firstPoint,secondPoint,thirdPoint,fourthPoint, pointListSrc)
        
        if(firstPoint==undefined || secondPoint==undefined || thirdPoint==undefined || fourthPoint==undefined) return false;     
                
        var angle1 = lineAngle(firstPoint, secondPoint, true);
        var angle2 = lineAngle(thirdPoint, fourthPoint, true);
        
        var rotationPoint1 = rotateAroundPoint(firstPoint, angle1+angleAddition, width);
        var rotationPoint2 = rotateAroundPoint(secondPoint, angle1+angleAddition, width);
        var rotationPoint3 = rotateAroundPoint(thirdPoint, angle2+angleAddition, width);
        var rotationPoint4 = rotateAroundPoint(fourthPoint, angle2+angleAddition, width);
        
        var intersectPoint = lineIntersect(rotationPoint1, rotationPoint2, rotationPoint3, rotationPoint4, false);
        
        
        //createCircle("x", intersectPoint, 2, "#ff00ff", "none", 0, layerCrop); 
        
        //createPath([rotationPoint1,rotationPoint2], "none", "#333", 1, "cropMask", layerCrop);
        //createPath([rotationPoint3,rotationPoint4], "none", "#f1f1f1", 1, "cropMask", layerCrop);
        
        
        //draw first point if open !closed
        if(i==0 & !closed){
            console.log("is false")
            pointListNew.push(rotationPoint1);
            //createCircle("x", rotationPoint1, 1, "#000", "none", 0, layer1);            
        }
        var drawLast = (i==pointListLen-2 & !closed)? true:false;     
    
        //Draw internal points        
        if(intersectPoint!=false & !drawLast){    
            pointListNew.push(intersectPoint);
            //createCircle("x", intersectPoint, 1, "#000", "none", 0, layer1);
        } 
    
        //draw last point if open
        if(drawLast){  
            var angle3 = lineAngle(pointList[pointListLen-2],pointList[pointListLen-1], true);
            var rotationPoint5 = rotateAroundPoint(pointList[pointListLen-1], angle3+angleAddition, width);
            //createCircle("x", rotationPoint5, 1, "#123456", "none", 0, layer1);
            pointListNew.push(rotationPoint5);      
        }
    }    
    return pointListNew;
}

function checkInsideCropBounds(pos,cropPoints){    
    return (pos.x>=cropPoints[0].x & pos.y>=cropPoints[0].y & pos.x<=cropPoints[1].x & pos.y<=cropPoints[1].y)==true;
}

function cropShapesBtn(){
    layerCrop.innerHTML = "";
    var croppedShapes = [];
    var shapeOutlines = [];
    outlineWidth = getCurrentDesign().outlineWidth;
    cropPoints = getCurrentDesign().cropPoints;    
    redrawShapes();    

    sessionData.rotatedShapes.forEach(function(shape){
        for(const point of shape){
            //if one is true then add and break
            if(checkInsideCropBounds(point,cropPoints)){ 
                croppedShapes.push(shape);
                //createPath(shape, "#561234aa", getCurrentDesign().outlineColour, 1, "croppedShape_x", layerCrop, false);
                break;
            }
        }
    }); 
    
    //console.log(croppedShapes)    
    //console.log(sessionData.rotatedShapes.length, croppedShapes.length);
    for(const shape of croppedShapes){
        //console.log(shape)
        //createPath(shape, "#123456", "#12345633", 1, "zzz", layerCrop);
        var outline = outlinePoints(shape, true, outlineWidth, true);
        if(outline!=false){
            //createPath(outline, "#123456aa", "#33ff33", 1, null, layerCrop);
            shapeOutlines.push(outline);
        }        
    }     
    //console.log(shapeOutlines)
    let i=0;
    for(const shapeOutline of shapeOutlines){    
        const path2 = cropShape2(shapeOutline);
        if(path2!=false){
            createPath(path2, "#563456aa", getCurrentDesign().outlineColour, 1, "croppedShape_" + i, layerCrop, false);
        }
        //const path = cropShape(shapeOutline);
        //createPath(path, "#123456aa", getCurrentDesign().outlineColour, 1, "croppedShape_" + i, layerCrop, false);
        i++
    };
}

function resetCropBtn(){
    layerCrop.innerHTML = "";
    updateCrop();
}



function getBounds(tl, br){
    //corners
    const tlc = {x:tl.x, y:tl.y};
    const trc = {x:br.x, y:tl.y}; 
    const brc = {x:br.x, y:br.y};
    const blc = {x:tl.x, y:br.y};
    //lines
    const topVal = {a:tlc, b:trc};
    const rightVal = {a:trc, b:brc};
    const bottomVal = {a:blc, b:brc};
    const leftVal = {a:blc, b:tlc};     
    //createPath([rightVal.a, rightVal.b], "none", "#ccc", 1, "zz", layer1);
    return {top:topVal, right:rightVal, bottom:bottomVal, left:leftVal};
}

function getIntersect(point, pointNext, bounds){
    var intersectList = [
    lineIntersect(point, pointNext, bounds.top.a, bounds.top.b, true),
    lineIntersect(point, pointNext, bounds.right.a, bounds.right.b, true), 
    lineIntersect(point, pointNext, bounds.bottom.a, bounds.bottom.b, true),
    lineIntersect(point, pointNext, bounds.left.a, bounds.left.b, true), 
    ]; 
    
    //var intersectListFiltered = intersectList.filter(function (el){
    //   return el != false;
    //});
    var sides = ['top', 'right', 'bottom', 'left'];
    var intersectListFiltered = [];
    intersectList.forEach(function(val, index){
        if(val!=false){
            val.index = sides[index];
            intersectListFiltered.push(val)
        }      
    });    
    
    if(intersectListFiltered.length == 0){
        //console.log("err: intersect not found", point.x, point.y, pointNext.x, pointNext.y, bounds);
        return false;
    }else{
        return intersectListFiltered;
    }
}

function basicDistance(first, last){
    return Math.abs(first.x - last.x) + Math.abs(first.y - last.y);
}


function cropShape2(shapePoints){
    const cropPoints = getCurrentDesign().cropPoints;
    const bounds = getBounds(cropPoints[0], cropPoints[1]);   
    let allInside = true;
    //if one of the points is outside then flag as false
    for(let i=0; i<shapePoints.length; i++){
        const point = shapePoints[i];  
        if(checkInsideCropBounds(point, cropPoints)==false){
            allInside = false;
            break;
        }
    }
    //if all points inside then return shape as is
    if(allInside){
        return shapePoints;
    }else{
    //check intersections and add points
    const newShapePoints = [];
    for(let i=0; i<shapePoints.length; i++){
        const point = shapePoints[i];
        const pointNext = shapePoints[getIndex(i+1, shapePoints.length)]; 
        const intersectTop = lineIntersect(point, pointNext, bounds.top.a, bounds.top.b, true);
        const intersectRight = lineIntersect(point, pointNext, bounds.right.a, bounds.right.b, true); 
        const intersectBottom = lineIntersect(point, pointNext, bounds.bottom.a, bounds.bottom.b, true);
        const intersectLeft = lineIntersect(point, pointNext, bounds.left.a, bounds.left.b, true);        
        if(checkInsideCropBounds(point, cropPoints)){
            newShapePoints.push(point)
        }        
        if(intersectTop!=false){
            newShapePoints.push(intersectTop);
        }
        if(intersectRight!=false){
            newShapePoints.push(intersectRight);
        } 
        if(intersectBottom!=false){
            newShapePoints.push(intersectBottom);
        }              
        if(intersectLeft!=false){
            newShapePoints.push(intersectLeft);
        }
        if(checkInsideCropBounds(pointNext, cropPoints)){
            newShapePoints.push(pointNext);
        }     
    }
    //close shape
    if(newShapePoints.length!=0){
        if((newShapePoints[0].x != newShapePoints[newShapePoints.length-1].x) || (newShapePoints[0].y != newShapePoints[newShapePoints.length-1].y)){
            newShapePoints.push(newShapePoints[0]);
        }
    }    
    //add corner points
    const newShapePointsCorner  = [];    
    for(let i=0; i<newShapePoints.length; i++){
        const point = newShapePoints[i];
        const pointNext = newShapePoints[getIndex(i+1, newShapePoints.length)];
        newShapePointsCorner.push(point);        
        if(point.x==bounds.left.a.x & pointNext.y==bounds.top.a.y){
            newShapePointsCorner.push({x:bounds.left.a.x, y:bounds.top.a.y})        
        }        
        if(point.y==bounds.top.a.y & pointNext.x==bounds.right.a.x){
            newShapePointsCorner.push({x:bounds.right.a.x, y:bounds.top.a.y})        
        }        
        if(point.x==bounds.right.a.x & pointNext.y==bounds.bottom.a.y){
            newShapePointsCorner.push({x:bounds.right.a.x, y:bounds.bottom.a.y})        
        }        
        if(point.y==bounds.bottom.a.y & pointNext.x==bounds.left.a.x){
            newShapePointsCorner.push({x:bounds.left.a.x, y:bounds.bottom.a.y})        
        }
        newShapePointsCorner.push(pointNext);    
    }
    return newShapePointsCorner;
    }   
}

function updateCrop(){
    if(sessionData.mode!="crop"){
        layerCrop.innerHTML = "";
        return false;
    }
    updatePoints(); //create crop circles
    sessionData.updating = true;
    const design = getCurrentDesign();
    const cropPoints = design.cropPoints;
    const height = Math.floor((100/design.zoom)*sessionData.svgHeight);
    const width = Math.floor((100/design.zoom)*sessionData.svgWidth);
    const tl = {x:design.panLeft, y:design.panUp};
    const br = {x:design.panLeft+width, y:design.panUp+height};
    const el = document.getElementById("cropMask");
    const path = `M${tl.x} ${tl.y} L${br.x} ${tl.y} L${br.x} ${br.y} L${tl.x} ${br.y} L${tl.x} ${tl.y} M${cropPoints[0].x} ${cropPoints[0].y} L${cropPoints[0].x} ${cropPoints[1].y} L${cropPoints[1].x} ${cropPoints[1].y} L${cropPoints[1].x} ${cropPoints[0].y} L${cropPoints[0].x} ${cropPoints[0].y}`;
    if(el==null){
        createPath(path, "#f1f1f133", "none", 0, "cropMask", layerCrop, false);
    }else{
        cropMask.setAttribute("d", path);
    }    
    sessionData.updating = false;
}

////////////////////////////////////////Crop Start//////////////////////////////////////////////////
////////////////////////////////////////Export Start //////////////////////////////////////////////////
function filterEmptyFromArray(arr){
    return arr.filter(element => element !== null & element !== undefined); 
}

function updateAndMapPoints(cent, pointList, ){
   //update   
   updatePointLengthAndAngles();
   return pointList.map(point => ({letter:point.letter, a:point.angle, l:point.length, r:point.rotation, c:point.connect}));
}

function exportCodeBtn(){
    var design = getCurrentDesign();
    var newPoints = filterEmptyFromArray(design.points);
    const cent = newPoints[0];
    newPoints = updateAndMapPoints(cent, newPoints);
    var newShapes = filterEmptyFromArray(design.shapes);
    newShapes = newShapes.filter(element => element.data.length !== 0); 
    newShapes = newShapes.map(shape => ({d:shape.data, r:shape.rotation, s:shape.skip, i:shape.include}));
    var newPatternPoints = filterEmptyFromArray(design.patternPoints);   
    newPatternPoints = updateAndMapPoints(cent, newPatternPoints);  
    console.log(JSON.stringify(newPoints) + ",\n" + JSON.stringify(newShapes) + ",\n" + JSON.stringify(newPatternPoints))
    //saveText("[" + JSON.stringify(newPoints) + ",\n" + JSON.stringify(newShapes) + ",\n" + JSON.stringify(newPatternPoints) + "]", design.title);
}

function triggerDownload(imgURI) {
    const a = document.createElement('a');
    a.download = getCurrentDesign().title + '.png'; // filename
    a.target = '_blank';
    a.href = imgURI;
    a.dispatchEvent(new MouseEvent('click', {
        view: window,
        bubbles: false,
        cancelable: true
    }));
}

function savePng(){
    const svgPoint = designSvg;
    const svgString = (new XMLSerializer()).serializeToString(svgPoint);
    const svgBlob = new Blob([svgString], {
        type: 'image/svg+xml;charset=utf-8'
    });
    const DOMURL = window.URL || window.webkitURL || window;
    const url = DOMURL.createObjectURL(svgBlob);
    const image = new Image();
    image.width = svgPoint.width.baseVal.value;
    image.height = svgPoint.height.baseVal.value;
    image.src = url;
    image.onload = function () {
        const canvas = document.getElementById('svgCanvas');
        canvas.width = image.width;
        canvas.height = image.height;

        const ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0);
        DOMURL.revokeObjectURL(url);

        const imgURI = canvas
        .toDataURL('image/png')
        .replace('image/png', 'image/octet-stream');
        triggerDownload(imgURI);
    };
}

function triggerDownloadSvg(imgURI, fileName){
    let a = document.createElement('a')
    a.setAttribute('download', getCurrentDesign().title + '.svg')
    a.setAttribute('href', imgURI)
    a.setAttribute('target', '_blank')
    a.click()
}

function saveSvg(){
    let data = (new XMLSerializer()).serializeToString(designSvg)
    let svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'})
    let url = URL.createObjectURL(svgBlob)
    triggerDownloadSvg(url)
}

function saveText(content, fileName, fileExt){
    const link = document.createElement("a");
    //const content = document.querySelector("textarea").value;
    const file = new Blob([content], { type: 'text/plain' });
    link.href = URL.createObjectURL(file);
    link.download = fileName + "." + fileExt;
    link.click();
    //URL.revokeObjectURL(link.href);
};

function exportShapesBtn(){
    backgroundImage.setAttribute("href","");
    cropMask.remove();
    clearLayers(true, false);
    saveSvg();
    loadBackgroundImage();
    updateCrop();
}

function joinPathsInLayer(layer){
    //var pathList = [];
    let pathString = "";
    const paths = layer.getElementsByTagName("path");
    for(var i=0; i<paths.length; i++){
        //pathList.push(paths[i].getAttribute("d"));
        pathString += paths[i].getAttribute("d") + " "
    }
    console.log(paths.length)
    return pathString.trim();    
}

function copySvgToClipboard(layer, sort){
    if(sort){
        sortPaths(layer);
    }    
    const svgStr = joinPathsInLayer(layer);
    navigator.clipboard.writeText(svgStr);

}

function exportPspnDataBtn(){
    updatePointLengthAndAngles();    
    const design = getCurrentDesign();
    let points = design.points;
    let shapes = design.shapes;
    let patternPoints = design.patternPoints;
    let pspnString = "";

    //points
    for(const [index, point] of points.entries()){
      pspnString += `point:${point.letter}, center:${letters[point.connect]}, angle:${point.angle}, length:${point.length}, rotation:${point.rotation}\n`   
    }
    //shapes
    for(const [index, shape] of shapes.entries()){
      pspnString += `shape:${index+1}, points:(${shape.data.toString()}), rotation:${shape.rotation}\n`        
    }
    //patterns    
    for(const [index, patternPoint] of patternPoints.entries()){
      pspnString += `pattern:p${index+1}, center:a, angle:${patternPoint.angle}, length:${patternPoint.length}}\n`  
    }
    console.log(pspnString);
    saveText(pspnString, design.title, "pspn");
}

function getPspnText(event, filePath){
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            importPspn(content, filePath);
        };
        reader.onerror = function(e) {
            console.error('Error reading file', e);
        };
        reader.readAsText(file);
    } else {
        console.log('No file selected');
    }
}

function importPspn(content, filePath){
    const linesList = content.split("\n");
    const pspnList = [];
    for(const line of linesList){
        if(line!=""){  
            let jsonString = '{' + line.replace(/\(/g, '["').replace(/\)/g, '"]') + '"}';
            jsonString = jsonString.replace(/(\w+):/g, '"$1":"');        
            jsonString = jsonString.replace(/,/g, '","').replace(/"\[/g, '[').replace(/\]"/g, ']');
            jsonString = jsonString.replace(/," "/g, ', "'); //fix double quotes
            //console.log(JSON.parse(jsonString)); 
            pspnList.push(JSON.parse(jsonString));    
        }
    }
    const designName = getFileNameFromPath(filePath).replace(".pspn", "");
    const newDesign = new Design(designName);
    newDesign.patternPoints = [];
    const centerOfRotation = {x:100, y:100}; //letter a point    
    for(const item of pspnList){
        const itemType = Object.keys(item)[0];
        if(itemType=="point"){
            const itemCenter = letters.indexOf(item.center);
            console.log(itemCenter)
            const centOfRotation = (itemCenter==0)? centerOfRotation:newDesign.points[itemCenter]
            const pos = rotateAroundPoint(centOfRotation, item.angle, item.length);
            const newPoint = new Point(pos.x, pos.y);
            newPoint.letter = item.point;
            newPoint.rotation = item.rotation;
            newPoint.connect = itemCenter;
            newDesign.points.push(newPoint);
        }else if(itemType=="shape"){
            const newShape = new Shape();
            newShape.data = item.points;
            newShape.rotation = item.rotation;            
            let colour = getHexColour(newDesign.shapes.length);
            newShape.fill = colour;
            newShape.stroke = colour;            
            newDesign.shapes.push(newShape);            
        }else if(itemType=="pattern"){
            const pos = rotateAroundPoint(centerOfRotation, item.angle, item.length);
            newDesign.patternPoints.push(pos);
        } 
    }
    console.log(newDesign)
    appData.designs.push(newDesign)
    appData.designIndex = appData.designs.length - 1;
    resetOnDesignChange(appData.designIndex);
}
////////////////////////////////////////Export End//////////////////////////////////////////////////
////////////////////////////////////////Grid Start//////////////////////////////////////////////////
//{ #region Grid
function addIsoGridPoints(point){
    for(var i=0; i<sessionData.gridSnapPoints.length; i++){ 
        const distance = calculateDistance(point, sessionData.gridSnapPoints[i], true);
        if(distance<5){
            //console.log("double:", distance)
            return false;
        }
    } 
    sessionData.gridSnapPoints.push(point);    
}
function createIsometricGrid(){
    if(sessionData.updating) return false;
    sessionData.updating = true;
    layerGrid.innerHTML = '<rect id="isoGridRect" x="0" y="0" width="0" height="0" fill="url(#isoGridPattern)" stroke="#f1f1f1" stroke-width="0.5"></rect>';
    sessionData.gridSnapPoints = [];
    const gridInfo =  getToolByName("isometricGrid");
    const rotation = gridInfo.rotation    
    const isometricRatio = Math.sqrt(3)/2; //0.8660254037844386    
    
    const xStart = gridInfo.points[0].x;
    //const yStart = gridInfo.points[0].y;    
    const xEnd = gridInfo.points[1].x;
    //const yEnd = gridInfo.points[1].y; 
    
    const gridWidth = xEnd-xStart;
    //const gridHeight = yEnd-yStart;
    
    //Based on hexagon so 2 * triangle
    let cellWidth = gridWidth/(gridInfo.xRepeat*2);    
    gridInfo.triangleHeight = cellWidth
    
    if(rotation==0){
        triangleHeight = gridInfo.triangleHeight/isometricRatio
        triangleWidth = gridInfo.triangleHeight;
    }else{ //rotation is 30
        triangleWidth = gridInfo.triangleHeight/isometricRatio;
        triangleHeight = triangleWidth/isometricRatio;
    }   
    const positionStart =  gridInfo.points[0] //{x:gridInfo.xStart, y:gridInfo.yStart}
    const hexagonPoints = polyShapePath(positionStart, triangleWidth, 6, rotation);
    hexagonPoints.unshift(positionStart);
    let xAdjust = 0;
    let yAdjust = 0;
    const xWidth = (rotation==0)? (triangleWidth * 2):(triangleHeight * 1.5);
    const yHeight = (rotation==0)? (triangleHeight * 1.5):(triangleWidth * 1.5);
    const start = (rotation==0)? triangleWidth:(triangleHeight*0.75);    
    for(var y=0; y<gridInfo.yRepeat; y++){         
        for(var x=0; x<gridInfo.xRepeat; x++){
            var hexPointsAdj = hexagonPoints.map(points => ({x:points.x+xAdjust, y:points.y+yAdjust})); 
            hexPointsAdj.forEach(function (point, index){
            if(rotation==0){
                if ((index!=2 & index!=3 & index!==4) || ((index==3 || index==4) & x==0)) {
                    //createCircle(null, point, 1, "#123456aa", "none", 1, layerGrid, null); 
                    addIsoGridPoints(point);       
                }
            }else{
                if (index==0 || index==4 || index==5) {
                    //createCircle(null, point, 1, "#561234aa", "none", 1, layerGrid, null);
                    addIsoGridPoints(point);
                }
            }
            });
            xAdjust += xWidth;    
        }
        xAdjust = (isEven(y))? start*1:0;
        yAdjust += yHeight;
    }     
    createCircle(null, positionStart, 3, gridInfo.colour, "none", 1, layerGrid, null); 
    gridInfo.points[1].y = hexPointsAdj[0].y
    //gridInfo.points[1] = gridInfo.points[1];    
    createCircle(null, gridInfo.points[1], 3, gridInfo.colour, "none", 1, layerGrid, null);

    //set pattern     
    let triHalfWidth = (triangleWidth) * isometricRatio ;
    let triDoubleWidth = (triangleWidth * 2) * isometricRatio;
    let tHeight = triangleHeight * isometricRatio;
    
    if(rotation==0){
        isoGridPattern.setAttribute("width", tHeight)
        isoGridPattern.setAttribute("height", triDoubleWidth);
        isoGridPath.setAttribute("d", `M0 0 L${tHeight} 0 L0 ${triDoubleWidth} L${tHeight} ${triDoubleWidth}L0 0 M0 ${triHalfWidth}  L${tHeight} ${triHalfWidth}`);
    }else{
        isoGridPattern.setAttribute("width", triDoubleWidth)
        isoGridPattern.setAttribute("height", tHeight);
        isoGridPath.setAttribute("d", `M0 ${tHeight} L0 0 L${triDoubleWidth} ${tHeight} M0 ${tHeight} L${triDoubleWidth} 0 M${triHalfWidth} 0 L${triHalfWidth} ${tHeight}`);
    }
    isoGridPattern.setAttribute("x", gridInfo.points[0].x + "px");
    isoGridPattern.setAttribute("y", gridInfo.points[0].y + "px");
    isoGridRect.setAttribute("x", gridInfo.points[0].x + "px");
    isoGridRect.setAttribute("y", gridInfo.points[0].y + "px");
    isoGridRect.setAttribute("width", gridWidth + "px");
    isoGridRect.setAttribute("height", (gridInfo.points[1].y - gridInfo.points[0].y)  + "px");
    isoGridRect.setAttribute("stroke", gridInfo.colour);
    isoGridPath.setAttribute("stroke", gridInfo.colour);      
    sessionData.updating = false;    
}

function createRectangularGrid(){
    layerGrid.innerHTML = "";
    sessionData.gridSnapPoints = [];
    const gridInfo = getToolByName("rectangularGrid");
    //gridInfo.constrain = true;
    const xStart = gridInfo.points[0].x;
    const yStart = gridInfo.points[0].y;    
    const xEnd = gridInfo.points[1].x;
    const yEnd = gridInfo.points[1].y;    
    const gridWidth = xEnd-xStart;
    const cellWidth = gridWidth/gridInfo.xRepeat;    
    let gridHeight =  yEnd-yStart;
    let cellHeight = gridHeight/gridInfo.yRepeat;
        
    if(gridInfo.constrain){
        cellHeight = cellWidth;
        gridHeight = yStart + (cellHeight*gridInfo.yRepeat);      
        gridInfo.points[1].y = gridHeight;
    }

    for(let x=0; x<=gridInfo.xRepeat; x++){
        let xPos = xStart + (x * cellWidth);
        createPath([{x:xPos, y:yStart},{x:xPos, y:gridInfo.points[1].y}], "none", gridInfo.colour, 1, null, layerGrid, false);
        for(let y=0; y<=gridInfo.yRepeat; y++){
            let yPos = yStart + (y * cellHeight);
            sessionData.gridSnapPoints.push({x:xPos, y:yPos});
            createCircle(null, {x:xPos, y:yPos}, 1, "#123456aa", "none", 1, layerGrid, null);
        }        
    }       
    for(let y=0; y<=gridInfo.yRepeat; y++){
        let yPos = yStart + (y * cellHeight);
        createPath([{x:xStart, y:yPos},{x:xEnd, y:yPos}], "none", gridInfo.colour, 1, null, layerGrid, false);    
    }

    createCircle(null, gridInfo.points[0], 1, "#561234aa", "none", 1, layerGrid, null);
    createCircle(null, gridInfo.points[1], 1, "#561234aa", "none", 1, layerGrid, null);
}

function hideGrid(){
    layerGrid.innerHTML = "";
}
//} #endregion Grid 
////////////////////////////////////////Grid End //////////////////////////////////////////////////
////////////////////////////////////////Initiation Start //////////////////////////////////////////
function init(){
    sessionData.svgWidth = designSvg.getAttribute("width");
    sessionData.svgHeight = designSvg.getAttribute("height"); 
    makeRotationBtns();
    getLocalStorage();
    changeBackgroundOpacity(getCurrentDesign().bgOpacity);
    createPointButtons();    
    createShapeButtons();
    updateDesignSelector();
    changeDesign(appData.designIndex); 
    selectMode('pointContainer','points'); 
    //exportPspnDataBtn(); //for testing    
    /*
    const path = [
    {x:100, y:100, rounding:0, roundingWeight:0}, 
    {x:200, y:50, rounding:0.4, roundingWeight:0}, 
    {x:300, y:100, rounding:0, roundingWeight:0}, 
    {x:200, y:200, rounding:0.4, roundingWeight:0}, 
    {x:100, y:100, rounding:0, roundingWeight:0}] //
    
    const artPath = articulatePoints(path);
    console.log(artPath);  
    createPath(artPath, "none", "#125634", 1, "xx", layerShapes, false); 
    */
}

init();
/*
myArrTemp = [];
myArr = [0,1,2,3,4];
var pos = 2;
for(var i=0; i<myArr.length; i++){
    myArrTemp[getIndex(pos, myArr.length)] = myArr[i];
    pos++
}
console.log(myArrTemp)
*/ 

function selectSnapsBtn(){
    sessionData.selectedSnaps = [];
    sessionData.selectedSnapsIsSelecting = true;
}



</script>
<script>
/*
var list = [];
var js = document.getElementById("kevin").innerHTML.split("\n");
for(var i=0; i<js.length; i++){
    var line = js[i].trim()
    if(line.includes("innerHTML")){
        var str = line.split(".inner")[0];
        if(!list.includes(str)) list.push(str);
    }
}
list.sort();
for(var i=0; i<list.length; i++){
    console.log("var " + list[i] + " = document.getElementById('" + list[i] + "');")
}
*/
</script>
</html>